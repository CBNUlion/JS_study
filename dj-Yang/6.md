# 객체
객체는 일종의 복합체로, 여러 값들을 묶어 이름으로 저장하고, 값을 가져올 수 있다.
프로퍼티의 이름은 문자열이기 때문에 객체는 문자열을 값에 대응시키는 구조. 자바스크립트 객체는 객체가 가진 고유 프로퍼티를 유지하는 것 외에 ‘프로토타입’이라고 하는 다른 객체의 프로퍼티를 상속 받는다. 객체의 메서드들은 일반적으로 상속받은 프로퍼티고, 이를 프로토타입 상속이라 한다.

자바스크립트 객체는 프로퍼티를 동적으로 추가하고 제거할 수 있기 때문에 동적이다. 하지만 정적으로 흉내낼 수 있고 정적 타입 언어에서의 ‘구조체’처럼 사용할 수도 있다.

자바스크립트에서는 문자열과 숫자, 불리언과null/undeifned를 제외한 나머지는 개체다. 문자열과 숫자, 불리언 값은 객체는 아니지만 변경 불가능한 객체처럼 행동한다.

프로퍼티는 이름과 값으로 구성된다. 프로퍼티 이름은 빈 문자열을 포함한 어떤 문자열이든 될 수 있다. 하지만, 같은 프로퍼티 이름을 2개를 가질 수는 없다. 객체는 프로퍼티 속성이라고 하는 연관된 값을 갖는다.
- 쓰기(writable) 속성은 프로퍼티 값의 수정 가능 여부를 결정한다.
- 열거(enumerable) 속성은 프로퍼티의 이름을 for/in 루프에서 읽을 수 있는 지 여부를 결정한다.
- 설정(configurable) 속성은 프로퍼티의 삭제 가능 여부와 프로퍼티 속성의 변경 가능 여부를 결정한다.

프로퍼티뿐만 아니라 모든 객체는 세 가지의 속성을 갖는다.
- prototype은 상속받은 프로퍼티들을 가진 객체를 참조한다.
- class는 객체의 자료형(타입)을 특정짓는 문자열이다.
- extensible 속성(ES5)은 객체에 새 프로퍼티를 추가할 수 있는지를 결정ㅇ한다.

세 부류의 자바스크립트 객체와 두 종료의 프로퍼티를 구분하기위해 사용하게 되는 용어
- ‘네이티브 객체(native object)’는 ES 명세에 정의된 객체 또는 그 객체의 클래스, Array, Function, Date, 정규 표현식들은 전부 네이티브 객체
- ‘호스트 객체(host object)’는 브라우저와 같이 자바스크립트가 내장된 호스트 환경에 정의된 객체. HTMLElement 객체는 웹 페이지의 구조가 클라이언트 측 자바스크립트로 표현된 호스트 객체, 호스트 환경에서 메서드들을 정의할 때 일반적으로 자바스크립트 Function 객로 정의하는 것과 마찬가지로, 호스트 객체는 네이티브 객체일 수 있다.
- ‘사용자 정의 객체(user-defined object)’는 객체에 직접 정의된 프로퍼티다.
- ‘상속받은 프로퍼티(inherited property)’는 객체의 프로토타입 객체가 정의한 프로퍼티를 말한다.
- ‘고유 프로퍼티(own property)’는 객체에 직접 정의된 프로퍼티다.

## 6.1 객체 생성하기
객체 리터럴을 통해 만들 수도 있고, new 키워드를 사용해 만들 수도 있다. 또한, ES5의 Object.create() 함수를 통해서도 생성할 수 있다.

### 6.1.1 객체 리터럴
객체를 생성하는 가장 쉬운 방법, 객체 리터럴은 중괄호({}) 안에, 이름과 값을 콜론(:)으로 구분한 순서 쌍을 쉼표(,)로 연결한 리스트. 프로퍼티 이름으로는 자바스크립트 식별자 또는 문자열을 사용할 수 있고, 값으로는 표현식(해당 값이 프로퍼티의 값이 된다)을 사용할 수 있다.
```javascript
var empty = {};					// 프로퍼티가 없는 빈 객체
var point = { x:0, y:0 };				// 두 개의 프로퍼티 x, y를 정의
var point2 = { x:point.x, y:point.y+1 };		// 프로퍼티를 수식의 값으로 정의
var book = {
	“main title”: “JavaScript”,		// 공백 가능
	“sub-title’: ”The Definitive Guide“,	// 하이폰(-) 가능
	“for”: “all audiences”,			// 예약어도 인용부호를 이용해 가능
	author: {				// 프로퍼티 author의 값은 객체
		firstname: “David”,		// 프로퍼티 이름은 인용부호를 감싸지
		surname“ ”Flanagan“,		// 않을 수도 있다.
	}
};
```
ES5에서 객체 리터럴의 마지막 프로퍼티 값 뒤에 오는 쉼표는 무시된다. 대부분의 ES3 구현체가 마지막 프로퍼티 값 뒤에 오는 쉼표는 무시하지만 IE는 이를 error로 간주한다.
객체 리터럴은 평가될 때마다 새로운 객체를 생성하고 초기화하는 표현, 각 프로퍼티의 값 또한 리터럴이 평가될 때마다 새롭게 계산된다. 이 말은 하나의 리터럴은 수 많은 객체를 만들 수 있다는 소리다.

### 6.1.2 new를 사용해 객체 생성하기
new 연산자는 객체를 만들고, 초기화하는 역할을 한다. new 키워드 다음에는 반드시 함수 호출분이 와야한다. 이때 호출되는 함수를 생성자(constructor)라고 하는데, 새로 생성된 객체를 초기화하는 역할을 한다.

>미리 작성된 생성자뿐 아니라, 원하는 형태의 객체를 생성하고 초기화하기 위해 임의의 생성상자 함수를 직접 정의할 수 있다.

### 6.1.3 프로토타입
자바스크립트의 모든 객체는 또 다른 자바스크립트 객체(null도 포함)와 연관되어 있다. 이 두 번재 객체는 프로토타입으로 알려져있고, 이때 객체는 프로토타입으로부터 프로퍼티들을 상속받는다. 객체 리터럴로 생성된 모든 객체는 프로토타입 객체가 같으며, 자바스크립트 코드에서 이 프로토타입 객체는 Object.prototype으로 참조할 수 있다. new 키워드를 사용해 생성자를 호출하면, 생성자 함수의 프로토타입이 생선된 객체의 프로토타입이 된다. 따라서 new Object()로 생선된 객체는 {}로 생성된 객체와 마찬가지로 Object.prototype을 상속받는다.

모든 내장 생성자는 Object.prototype을 상속하는 객체를 프로토타입으로 갖는다. 예를 들어, Date.prototpye은 object.prototype의 프로퍼티들을 상속받는다. 따라서 new Date()를 통해 생성된 객체는 Date.prototype과 Object.prototype으로부터 프로퍼티를 상속받게 된다. 이처럼 프로토타입 객체들이 연결된 것을 **프로토타입 체인**이라고 한다.

### 6.1.4 Object.create()
ES5는 객체를 생성하는 Object.create() 메서드를 지원한다. 메서드의 첫 번째 인자가 프로토타입 객체다. 두 번째 인자로 새 객체의 프로퍼티 인자를 받을 수 있고 생략또한 가능한다. Object.create()는 정적 함수로, 개별 객체를 통해 호출되는 메서드가 아니다. 함수를 사용하기 위해서는 단순히 프로토타입 객체를 넘기기만 하면된다.
```javascript
var o1 = Object.create({x:1, y:2});		// 91은 x,y 프로퍼티를 상속받는다.
```

프로토타입을 갖지 않는 새 객체를 만들기 위해서는 함수에 null을 전달하면 된다. 하지만, 이 경우에는 toString()과 같은 기본적인 메서드, 연산자 또한 사용할 수 없다.
```javascript
var o2 = Object.create(null);			// o2에는 프로퍼티와 메서드가 없다.
```

만약 {}. 또는 new Object()가 만들어내는 것 같이 빈 객체를 만들고 싶다면 Object.prototype을 전달한다.
```javascript
var o3 = Object.create(Object.prototype);
```

## 6.2 프로퍼티 접근 및 설정
프로퍼티의 값을 가져오기 위해서는 마치표(.) 연산자 또는 대괄호([]) 연산자를 사용한다. 프로퍼티를 만들거나 설정하기 위해서 객체의 프로퍼티에 접근할 때 역시 동일하다. ES3에서는 마침표(.) 연산자 다음에 오는 식별자로 예약어를 사용할 수 없다. 반드시 []를 사용했지만 ES5에서는 사용할 수 있다. [] 연산자를 사용할 경우, 연산자 안에 문자열로 평가되는 표현식이 들어가야한다고 했다. 정확히는 문자열 표현식 또는 갑싱 문자열로 변환될 수 있는 표현식이어야 한다.

### 6.2.1 연관 배열로서의 객체
밑의 두 표현식은 동일한 값을 갖는다.
```javascript
object.property
object[“property”]
```
첫 번째 구문은 마침표 연산자와 식별자를 사용했고, 이는 C의 구조체나 자바 객체의 필드에 접근할 때 사용하는 구문과 유사하고, 두 번째 구문은 대괄와 문자열을 사용했는데, tnt자가 아닌 문자열을 인덱스로 갖는 배열에 접근하는 형태와 유사하다. 이러한 형태의 배열을 연관 배열이라고 하고, 해시(hash), 맵(map)이나 사전(dictionary)이라고도 한다. 모든 자바스크립트 객체는 **연관 배열**이다.

타입의 제약이 엄격한 언어에서 객체는 오직 정해진 개수의 프로퍼티를 갖고, 프로퍼티 이름을 미리 정의해야했지만 자바스크립트 같은 경우는 수많은 프로퍼티를 만들 수 있다. 하지만 마침표 연산자를 사용해 객체의 프로퍼티를 접근할 때는 프로퍼티의 이름을 반드시 식별자로 표현해야 한다.
>식별자 : 자바스크립트 프로그램에 직접 타이핑해 넣은 이름이며 자료형이 없으므로 프로그램이 실행되는 도중에 변경할 수 없다.

반면에 [] 연산자를 사용해 접근할 때는 프로퍼티의 이름을 문자열로 표현한다. 문자열은 프로그램 실행 중에 생성하고 조작가능하다. 따라서 아래와 같은 코드를 객체에 이용할 수 있다.
```javascript
var addr = “”;
for(i = 0; i < 4; i++) {
	addr += customer[“address” + i] + ‘\n’;
}
```
위의 예제에서 객체의 프로퍼티에 접근하기 위해 문자열 표현식과 배열의 표기법을 함께 사용하는 방식의 유연함을 보여준다.

프로그래머는 객체의 프로퍼티에 접근할 때 마침표(.) 연산자 또는 대괄호([])를 통해 접근할 지를 상황에 따라서 판단해야 한다.

for/in루프와 같은 자바슼릡트 문장의 강력한 점 역시 연관 배열과 함께 사용할 때 명확해진다. 다음은 portfolio 객체가 가진 주신의 총액을 계산하는 코드이다.
```javascript
function getvalue(portfolio) {
	var total = 0.0;
	for(stock in portfolio) {
		var shares = portfolio[stock];
		var price = q=getquote(stock);
		total += shares * price;
	}
	return total;
}
```

### 6.2.2 상속
자바스크립트 객체는 고유 프로퍼티들을 가지고 있고, 동시에 해당 객체의 프로토타입 객체로부터 여러 프로퍼티를 상속받는다. 만약, 객체 o에서 프로퍼티 x를 찾는 상황에서 객체 o에 프로퍼티 x가 없다면 o의 프로토타입 객체에서 프로퍼티 x를 찾는다. 이 작업은 prototype이 null인 객체가 나올 때까지 반복한다. 이러한 prototype 속성은 프로퍼티가 계승되는 체인 또는 연결리스트를 생성한다.

객체 o의 프로퍼티 x에 값을 설정하려고 할 때, 객체 o가 상속받지 않은 고유 프로퍼티 x를 가지고 있는 경우에는 기존의 프로퍼티 값을 단순히 바꾼다. 프로퍼티 x를 가지고 있지 않는 경우에는 객체 o에 프로퍼티 x를 만든 후 값을 설정한다. 만일 객체 o가 프로퍼티 x를 상속받은 상태였다면 기존에 상속받았던 x값은 새로 설정되는 값에 가려진다.

객체의 프로퍼티 값을 설정할 때 해당 프로퍼티에 값을 설정할 수 있는지 알아보기 위해 프로토타입 체인을 검사한다. 객체 o가 상속한 프로퍼티x가 만약 읽기 전용이라면 해당 프로퍼티에는 값을 설정할 수 없다. 설정 가능하다면 위와 같은 프로세스가 진행된다.

>프로퍼티를 질의할 때는 상속이 동작(해당 객체의 프로퍼티가 없다면 위까지 확인한다.)하지만 설정할 때는 그렇지 않다는 것은 자바스크립트의 중요한 특징이다.

주의할 점은 객체 o가 프로퍼티 x를 상위 객체로부터 상속 받았고 이 프로퍼티가 setter메서드를 가진 접근자 프로퍼티라고 가정한다면 객체 o에 새 프로퍼티 x가 만들어지는 대신, 상속받은 프로퍼티 x가 가진 setter 메서드가 호출된다. 하지만 이 메서드는 프로퍼티 x가 정의된 프로토타입 객체에 호출되는 것이 아니라, 객체 o에 호출된다. 이 메서드가 새로운 프로퍼티를 정의해도 프로토타입 체인은 변경되지 않는다.

### 6.2.3 프로퍼티 접근 에러
프로퍼티 접근 표현식을 사용해도 항상 값을 얻을 수 있거나 값을 설정할 수 있는 것은 아니다.

존재하지 않는 프로퍼티에는 접근해도 에러가 발생하지 않는다. 만약, 프로퍼티 x가 객체 o의 고유 프로퍼티나 상속된 프로퍼티에 존재하지 않을 경우 o.x의 값은 undefined가 된다.

존재하지 않는 객체의 프로퍼티에 접근하려고 하면 에러가 발생한다. unll이나 undefined 값은 어떠한 프로퍼티도 같지 않기 때문이다.

해당 예외를 막기 위한 방법
```javascript
// 구체적이고 확실한 방법
var len = undefined;
if (book) {
	if (book.subtitle)
		len = book.subtitle.length;
}

// 간단하고 관영적인 방법
var len = book && book.subtitle && book.subtitle.length;
```

null이나 undefined가 아닌 값이라고 해도 프로퍼티가 읽기 전용 속성을 가지고 있어 값을 설정할 수 없을 수 있고, 객체가 새 프로퍼티를 추가하는 것을 허용하지 않을 수도 있다.
```javascript
// 내장된 생성자의 프로토타입 프로퍼티들은 읽기 전용이다.
Object.prototype = 0;
```
문제 없이 실행되나 값은 바뀌지 않고 예외도 발생하지 않는다.
위의 오류는 ES5의 엄격모드에서 수정되었다.

다음과 같은 경우에는 객체 o의 프로퍼티 p를 설정할 수 없다.
- 객체 o가 고유 프로퍼티 p를 가지고 있고, 읽기 전용인 경우(configurable read-only 프로퍼티라면 예외적으로 값을 설정할 수도 있다.)
- 객체 o는 상속된 프로퍼티 p를 가지고 있고, 읽기 전용일 경우.
- 객체 o에 고유 프로퍼티 p가 없고, 프로퍼티 p를 상위 객체로부터 상속받지 않았으며, 객체의 extensible속성이 false 인 경우 : 만일 프로퍼티 p각 객체 o에 존재하지 않고 setter 메서드도 호출되지 않았다면 p는 반드시 o에 추가되어야 하지만 객체 o의 extensible 속성이 true가 아니라면 새로운 프로퍼티 추가가 불가능하다.

## 6.3 프로퍼티 삭제하기
delete 연산자는 객체의 프로퍼티를 삭제한다. 이 값은 프로퍼티의 값을 지우는 게 아니라 **프로퍼티**를 지운다.
```javascript
delete book.author;			// book 객체의 author 프로퍼티가 삭제
delete book[“main title”];		// ’main title’ 프로퍼티 삭제
```
단, 상속받은 프로퍼티가 아닌 고유 프로퍼티만 지울 수 있는데 만약 상속받은 프로퍼티를 지우고 싶다면 해당 프로퍼티가 저으이된 프로토타입 객체에서 지워야한다(만약, 삭제에 성공한다면 상속받은 모든 객체가 영향을 받는다.)

delete 표현식은 삭제에 성공하거나, 프로퍼티가 존재하지 않아서 아무 영향도 끼치지 못한 경우에는 true로 평가, 피연산자가 올바른 프로퍼티 접근 표현식이 아니라서 아무 효력도 낼 수 없는 경우도 마찬가지이다.
```javascript
o = {x:1};
delete o.x;		// true
delete o.x;		// true(아무일도 일어나지 않음)
delete o.toString;	// 고유 프로퍼티가 아니기 때문에 아무일도 일어나지 않음 true
delete 1;		// true
```

delete 연산자는 configurable 속성이 false인 프로퍼티를 지우지 않는다.(단, ‘확장할 수 없는(nonextensible)’ 객체에 속한 configurable 속성이 true인 프로퍼티들은 지운다.)
[위에 부분 이해 안되는구만]
내장 객체의 특정 프로퍼티들은 변수 선언이나 함수 선언 결과로 만들어진 전역 객체 프로퍼티와 마찬가지로 속성을 변경할 수 없다.(nonconfigurable).
```javascript
delete Object.prototype;			// 속성 변경이 불가능한 프로퍼티
var x = 1;
delete this.x;				// 전역 객체의 프로퍼티 x는 지울 수 없다.
function f() {}
delete this.f;				// 전역 객체의 함수 f는 지울 수 없다.
```

## 6.4 프로퍼티 검사하기
자바스크립트 객체는 일종의 프로퍼티 집합이다. 때때로 이 집합에 주어진 이름의 프로퍼티가 있는 지를 검사할 필요가 있다. in, hasOwnProperty(), propertyIsEnumerable() 메서드를 사용해서 가능하다.

hasOwnProperty() 메서드는 주어진 이림의 프로퍼티가 객체에 존재하는 지를 검사한다. 상속받은 프로퍼티의 경우에도 false를 반환한다.

propertyIsEnumerable() 메서드는 위의 메서드보다 상세한 검사를 한다. 객체에 주어진 이름의 고유 프로퍼티가 존재하고, 열거할 수 있는(enumerable 속성이 true)인 프로퍼티일 경우에만 true를 반환한다.
>일부 내장 프로퍼티들은 열거할 수 없다. ES5 메서드 중에는 프로퍼티를 열거할 수 없게 만드는 메서드가 있다. 이 외의 일반적으로는 자바스크립트 코드로 생성한 프로퍼티들은 열거할 수 있다.

## 6.5 프로퍼티 열거하기
객체가 가진 각 프로퍼티들이 존재하는지 테스트하기보다는 객체가 가진 모든 프로퍼티를 순회해야할 상황이 있다. ES5에는 두 가지 편리한 방법이 있지만, 보통 for/in 루프로 해결한다.

지정한 객체가 가진 고유 프로퍼티 또는 상속된 프로퍼티들 중 열거 가능한 프로퍼티들마다 for/in 루프의 몸체가 실행된다. 상속받은 내장 메서드는 열거할 수 없지만, 사용자가 임의로 추가한 프로퍼티들은 열거할 수 있다.

일부 유용한 라이브러리들은 Object.prototype에 메서드나 프로퍼티들을 추가해서 모든 객체에서 사용할 수 있도록 하고 있다. ES5 이전 버전에는 메서드나 프로퍼티들을 열거할 수 없도록 만들 방법이 없었으믈, 항상 열거될 수 밖에 없었다. for/in 루프를 통해 열거되는 것을 막는 방법은 아래와 같다
```javascript
for(p in o) {
	if (!o.hasOwnProperty(p))
		continue;
}
for(p in o) {
	if (typeof o[p] === “function”) 		//메서드면 생략
		continue;
}
```

for/in 루프 말고도 ES5에는 프로퍼티 이름을 열거하는 두 가지 함수가 존재한다.
1. Object.keys() : 객체가 가진 고유 프로퍼티 중에 열거할 수 있는 프로퍼티 이름을 배열에 담아 반환한다(keys() 유틸리티 함수와 같이 동작)
2. Object.getOwnPropertyNames() : 프로퍼티를 열거하는 함수로 해당 객체가 가진 모든 고유 프로퍼티의 이름을 배열로 반환한다.

## 6.6 프로퍼티 Getter와 Setter
ES5에서 프로퍼티의 값은 getter/setter 메서드로 대체할 수 있다. 이들은 단순히 값을 갖는 ‘데이터 프로퍼티’와는 다른 ‘접근자 프로퍼티’라고 한다.
프로그램이 객체의 접근자 프로퍼티의 값에 접근하면 자바스크립트 엔진은 getter 메서드를 아무런 인자 없이 호출한다. 이때 getter 메서드의 반환 값이 접근 표현식의 값이 된다. 유사하게 프로퍼티의 값이 변경하려고 할 때는 setter 메서드를 호출한다. 이때, 할당자(=)의 오른쪽에 있는 값을 setter 메서드의 인자로 전달하고 반환 값은 무시된다.

데이터 프로퍼티가  writable(쓰기) 갖는 반면, 접근자 프로퍼티는 쓰기 속성을 갖지 않는다. getter/setter 메서드를 모두 가지고 있다면 읽기/쓰기 모두 가능한 프로퍼티인 것이고, 프로퍼티가 getter메서드만 가지고 있다면 읽기 전용 프로퍼티이다. 프로퍼티가 setter만 가지고 있다면 쓰기 전용 프로퍼티이며, 읽기를 시도하면 undefined 값을 반환한다.

아래는 접근자 프로퍼티를 가장 쉽게 정의하는 방법이다.
```javascript
var o = {
	// 데이터 프로퍼티
	data_prop: value,
	// 한 쌍의 함수로 정의된 접근자 프로퍼티
	get accessor_prop() { /* 함수 몸체 */ },
	set accessor_prop(value) { /* 함수 몸체 */ }
};
```
함수 정의에 사용되는 function 키워드 대신 get/set을 사용하고, 기존 객체 프로퍼티 정의와는 달리 프로퍼티 이름 뒤에 콜론을 사용하지 않는다.

또한 함수 몸체에서 자기 자신을 가르킬 때 **this**키워드를 사용하는 것을 유의해야한다.
```javascript
var o = {
    data_prop: 3,
    get accessor_prop() { console.log("여긴 getter" + this.data_prop); },
    set accessor_prop(value) { this.data_prop = value; }
};

o.accessor_prop;		// “여긴 getter3“
o.accessor_prop = 10;		// “여긴 getter10“
o.accessor_prop;		// “여긴 getter10“
```
## 6.7 프로퍼티 속성
프로퍼티에는 프로퍼티로 할 수 있는 작업을 결정하는 세 가지 속성 writable, enumerable, configurable이 있다.
- writable은 프로퍼티 값의 변경 가능 여부를 결정한다.
- enumerable은 프로퍼티가 열거될 수 있는 지 여부를 결정한다.
- configurable은 configurable 속성뿐 아니라 writable 속성과 enumerable 속성 값의 변경 가능 여부를 결정한다.

ES3 에서는 모든 프로퍼티들이 위의 세 가지 속성 전부 가능하다. 따라서 ES5부분에 주목해야하며 여기서 사용되는 API는 라이브러리를 만들 경우 더 중요하다. 이유는 아래와 같다.
- 프로토타입 객체에 메서드를 추가할 수 있고, 추가된 메서드를 내장 메서드처럼 열거할 수 없게 만들 수 있다.
- 변경하거나 삭제할 수 없는 프로퍼티를 정의하여, 객체를 고정(lock down)시킬 수 있다.

속성을 다루기 위해 getter/setter 접근자 메서드를 사용할 것이며, 이것으로 보아 **데이터 프로퍼티의 값** 또한 **속성**이라고 할 수 있다.

>프로퍼티의 속성 : value, writable, enumerable, configurable

접근자 속성의 경우 value나 writable 속성을 갖지 않는데, writable 속성은 setter 메서드의 존재여부에 따라 결정되기 때문이다.

>접근자 프로퍼티의 속성 : get, set, enumerable, configurable

ES5이 메서드는 접근자 프로퍼티의 네 가지 속성을 표현하기 위해 ‘프로퍼티 디스크립터(property decriptor)’라는 객체를 사용한다. 이 객체의 프로퍼티 이름은 표현 대상 속성의 이름과 같다. 따라서, 데이터 프로퍼티의 프로퍼티 디스크리터 객체는 **프로퍼티의 속성** 의 프로퍼티를 갖는다.

writable, enumerble, configurable 프로퍼티는 boolean 값을 갖고, get과 set 프로퍼티는 function을 값으로 갖는다.

객체가 가진 특정 프로퍼티에 대한 프로퍼티 티스크립터 객체는Object.getOwnPropertyDescriptor()를 통해 얻을 수 있다. 이 메서드는 이름에서 알 수 있듯이 객체의 고유프로퍼티에서만 동작한다. 상속받은 프로퍼티나 존재하지 않은 프로퍼티의 경우 undefined를 반환한다.

>상속된 프로퍼티의 속성을 검사하기 위해서는 프로토타입 체인을 명시적으로 직접 순회해야한다. getPrototypeOf() 차모

프로퍼티 속성을 설정하거나 임의의 속성으로 새 프로퍼티를 만들기 위해서는 Object.defineProperty()를 호출하며, 함수의 인자로 수정할 객체와 추가하거나 변경할 프로퍼티 이름, 프로퍼티 디스크립터 객체를 넘긴다.
```javascript
var o = {};

Object.defineProperty(o, "x", {value: 1,
                               writable: true,
                               enumerable: false,
                               configurable: true});
```
writable이 false로 되어있다면 x의 값을 변경할 수 없다. 하지만 configurable 속성이 true이기 때문에 직접적으로 value를 위의 메서드를 이용해 설정해주면 값을 변경할 수 있다.

프로퍼티 디스크립터 객체를 인자로 넘길 때 반드시 네 개의 프로퍼티가 있어야할 필요는 없다. 새 프로퍼티를 만들 때는 생략된 속성은 false나 undefined로 처리되며, 기존의 프로퍼티의 속성을 수정한다면 생략된 속성은 기존값을 유지하게 된다. 또한 defineProperty() 메서드는 기존 프로퍼티나 새로 만든 고유 프로퍼티의 속성은 바꾸지만 상속받은 속성은 바꾸지 않는다.

동싱 여러 개의 프로퍼티를 만들거나 수정하고 싶을 때는 Object.defineProperties()를 사용한다. 메서드의 첫 번째 인자는 수정하려는 객체, 두 번째는 객체에 만들거나 수정하려는 프로퍼티 이름과 프로퍼티 디스크립터 객체를 값으로 갖는 객체다.
```javascript
var p = Object.defineProperties({}. {
	x: { value; 1, writable: true, enumerable: true, configurable: true },
	y: { value; 1, writable: true, enumerable: true, configurable: true },
	r: {
		get: function() { return Math.sqrt(this.x*this.x + this.y*this.y) },
		enumerable: true,
		configurable: true
	}
});
```

이전에 배운 Object.create() 또한 첫 번째 인자로 생성할 객체의 프로토타입을 받고 두 번째 선택인자로 위의 두 번째 인자를 받는다. 위와 같은 역할을 한다.

위의 두가지 메서드는 프로퍼티를 추가하거나 수정할 수 없는 객체에 사용하면 Typerror 예외가 발생한다. 확장 불가능한(nonextensible) 객체가 예시다. 또한 객체의 속성 때문에 같은 예외가 발생하기도 한다. 예를 들어 configurable 속성은 자신 속성을 비롯해 다른 속성의 변경 여부를 결정한다.(삭제될 수 있는지 까지) 그렇기 때문에 writable 속성이 false라고 해도 직접적으로 value로 값 변경이 가능한 상황이 나온다.

위와 같은 상황을 지양하기 위해 아래와 같은 규칙이 있다.
- extensible 하지 않은 객체는 기존의 고유 프로퍼티를 수정할 수 는 있지만 새 프로퍼티를 주가할 수는 없다.
- 프로퍼티의 configurable 속성 값이 false면, configurable 속성 값뿐 아니라 enumerable 속성 값도 바꿀 수 없다.
- 접근자 프로퍼티의 configurable 속성 값이 false면, getter/setter 메서드를 변경할 수도 없고, 데이터 프로퍼티를 바꿀 수도 없다.
- 데이터 프로퍼티의 configurable 속성 값이 false면, 데이터 프로퍼티를 접근자 프로퍼티로 바꿀 수 없다.
- 데이터 프로퍼티의 configurable 속성 값이 false면, 기존의 writable 속성을 false에서 true로 바꿀 수 없다. 하지만 true에서 false로 바꾸는 것은 가능하다.
- 데이터 프로퍼티의 configurable 속성 값과 writable 속성 값이 false면, 프로퍼티 값을 바꿀 수 없다. 하지만 프로퍼티의 configurable 속성 값이 true고, writable 속성 값이 false인 경우에는 프로퍼티의 값을 바꿀 수 있다.

객체가 가진 프로퍼티들을 다른 객체로 복사하는 extend() 함수는 프로퍼티의 이름과 값 외에 프로퍼티가 가진 속성은 무시한다. 뿐만 아니라, 접근자 프로퍼티의 getter/setter 메서드도 복사하지 않는다. 대신 메서드를 정적 데이터 프로퍼티로 바꾼다. 하지만, 위의 메서드들을 사용하여 속성까지 복사가 가능하다.

### 6.7.1 Getter/Setter 메서드를 지원하는 레거시 API
객체 리터럴 문법을 사용하면 새 객체를 만들 때 접근 프로퍼티를 정의할 수는 있지만, getter/setter 메서드의 존재여부를 검사하거나 기존 객체에 새 접근자 프로퍼티를 추가할 수 없다. ES5에서는 Object.get OwnPropertyDecriptor()와 Object.defineProperty() 메서드를 사용하면 가능하다.

대다수 브라우저에 내장된 자바스크립트 엔진에서는 ES5가 나오기 전부터 get/set 문법을 지원했다. 엔진들은 getter/setter메서드를 검사하고 설정하는 비표준 레거시 API를 지원한다. __lookupGetter__()와 __lookupSetter__()는 각각 해당 프로퍼티에 설정된 getter/setter 메서드를 반환한다. 그리고 __defineGetter()__와 __defineSetter__()는 각각 getter/setter 메서드를 정의한다.

## 6.8 객체 속성
모든 객체는 prototype, class, extensible 속성을 가지고 있다.

### 6.8.1 prototype 속성
객체의 prototype 속성은 프로퍼티를 상속하는 객체를 지정한다. prototype 속성은 객체가 만들어지는 시점에 설정된다. 객체 리터럴을 통해 만든 객체는 Object.prototype을 객체의 프로토타입으로 설정한다. new를 사용해 만든 객체는 생성자 함수의 prototype 프로퍼티 값이 prototype 속성의 값이 되고, Object.create() 메서드로 만든 객체는 메서드의 첫 번째 인자가 프로토타입 속성의 값이 된다.

ES5에서는 Object.getPrototypeOf()에 객체를 전달해 객체의 프로토타입을 검사할 수 있다.

new 표현식으로 생성된 객체는 일반적으로 객체를 만드는 데 사용되는 생성자 함수를 참조하는 ‘constructor 프로퍼티’를 상속받는다. 그 후 생성자 함수는 생성자를 사용해 만든 객체의 프로토타입을 prototype 프로퍼티로 갖는다.

객체 리터럴이나 Object.create()로 생성된 객체는 Object()의 생성자를 constructor 프로퍼티로 갖는다. 따라서 constructor.prototype은 객체 리터럴에 대해서는 정확한 프로토타입을 참조하지만 Object.create()로 생성된 객체의 경우는 그렇지 않다.

객체 A가 객체 B의 프로토타입인지 알아보기 위해서는 isPrototypeOf() 메서드를 사용한다. isPrototypeOf() 함수는 instanceof 연산자와 비슷한 동작을 한다.

### 6.8.2 class 속성
객체이 class 속성은 객체의 타입에 대한 정보를 담고 있는 문자열이다. ES3와 ES5 모두 이 속성을 변경할 수 없고, 질의 하는 것도 간접적으로만 가능하다.

Object.prototype으로부터 상속되는 기본 toString() 메서드는 객체의 타입을 아래 형태의 문자열로 반환한다.

>[object class]

객체의 클래스 정보를 알아보기 위해서는 객체의 toString() 메서드를 호출하면 된다. 이때 반환되는 스트링의 아홉 번째 문자열부터 문자열 끝에서 두 번째 문자까지 추출한다. 많은 객체들이 유용한, 다른 toString()을 상속받기 때문에 원하는 toString() 메서드를 호출하려면 Function.call() 메서드를 사용해 간접적으로 호출해야한다.

classof() 함수는 어떠한 자바스크립트 값을 넣어도 동작한다. 숫자, 문자열, 불리언 값은 toString() 메서드를 호출할 때 객체처럼 동작하고, null과 undefined인 경우도 처리한다. Array나 Date와 같은 내장 생성자를 통해 생성된 객체는 생성자의 이름을 딴 class 속성을 가진다. 호스트 객체도 객체의 구현에 따라서 다르지만 일반적으로 의미 있는 *class* 속성을 갖는다.

객체 리터럴이나 Object.create()를 사용해 생성된 객체의 *class*속성 값은 “Object”다. 생성자 함수를 임의로 정의하고 객체를 만들더라도 *class*속성 값은 “Object”가 된다.
```javascript
classof(window)			// “Window“
classof([])			// “Array“
classof(/./)			// “Regexp“
classof(1)			// “Number“
function f() {};			// 생성자 함수를 임의로 생성
classof(new f());			// ’Object
```

### 6.8.3 extensible 속성
객체의 extensible 속성은 새 프로퍼티를 추가할 수 있는 지 여부를 결정한다. ES3는 특별한 경우가 아니면 모든 내장 객체와 사용자 정의 객체는 확장 가능하고 ES5도 확장할 수 없게 바뀌지 않는 한 가능하다.

ES5에는 Object.isExtensible() 함수를 통해 확장할 수 있는 객체인지 알아볼 수 있다. 또한, Object.preventExtensions()에 객체를 넘겨 확장할 수 없도록 만들 수 있다. 딴 Obejct.preventExtensions()에 의해 확장할 수 없는 상태가 된다면 다시 전 상태로 돌아갈 수 없다. Obejct.preventExtensions() 함수는 오직 해당 객체의 extensible 속성만 변경하기 때문에 프로토타입에 새 프로퍼티를 추가하면, 해당 객체에도 상속된다.

extensible의 목적은 ‘잠겨있는’객체의 상태를 고정하고 외부에서 변경하는 것을 막는 것이며 종종 configurable, writable 속성과 함께 사용한다. ES5에서는 이 3개의 속성을 동시에 바꿀 수 있는 Object.seal() 함수를 제공하는데 이 함수는 객체를 확장할 수 없게 만들뿐만 아니라 객체가 가진 모든 고유 프로퍼티를 설정불가능하게 만든다.(프로퍼티 추가 x, 기존 프로퍼티 설정 삭제 or 수정 x), Object.seal()함수를 사용해도 writable 속성이 true인 기존 프로퍼티의 값은 변경할 수 있다. Obejct.seal() 메서드로 봉인한 객체는 전 상태로 돌아갈 수 없고, Object.isSealeD() 메서드를 사용해 봉인 여부를 확인할 수 있다.

Object.freeze() 메서드는 Object.seal보다 단단히 객체를 확장할 수 없게 만들고 프로퍼티 설정을 바꿀 수 없게 만들면서 객체가 가진 프로퍼티를 전부 읽기 전용으로 만든다.(단, 객체가 접근자 프로퍼티로 setter 메서드를 가지고 있다면, 프로퍼티가 읽기 전용으로 바뀌었더라도 setter 메서드를 이용해서 프로퍼티 값을 변경할 수 있다.) freeze여부는 Object.isFrozen()메서드를 통해 확인할 수 있다.

Object.seal()과 Object.freeze()는 주어진 객체 고유 프로퍼티에만 영향을 끼치기 때문에 객체를 확실하게 잠그려면 프로토타입 체인까지 잠궈야한다.

Object.prventExtensions()와 Object.seal(), Object.freeze() 메서드들은 인자로 넘겼던 객체를 다시 반환하기 때문에 아래와 같이 한줄로 사용 가능하다.
```javascript
var o = Object.seal(
	Object.create(Object.freeze({x:1}), {y: {value: 2, writable: true}}));
```

## 6.9 객체 직렬화하기
객체 직렬화는 객체의 상태를 문자열로 변환하는 과정이다. 생성된 문자열은 나중에 객체 복원에 사용할 수 있다. ES5에서는 직렬화 시키는 JSON.stringify() 메서드와 JSON.parse() 메서드를 지원한다.

>JSON : JavaScript Object Notation => 객체 리터럴이나 배열 리터럴의 문법과 매우 유사

JSON 문법은 자바스크립트 문법의 부분 집합이므로 자바스크립트의 모든 값을 표현할 수는 없다. 객체와 배열, 문자열, 유한한 수, true, false, null은 직렬화와 복원 모두 가능하다. NaN와 Infinity, -Infinity는 null로 직렬화된다. Date 객체는 ISO 날짜 형식을 따르는 문자열로 직렬화된다. 그러나 JSON.parse() 함수는 문자열을 Date 객체로 복원하지 않는다. Function, regExp, error객체와 undefined 값은 직렬화하거나 복원이 불가능하다.

JSON.stringify() 메서드는 객체가 가진 열거 가능한 고유 프로퍼티만 직렬화한다. 직렬화할 수 없는 프로퍼티 값은 직렬화 결과에 추가되지 않는다.

JSON.stringify()와 JSON.parse()함수는 두 번째 선택 인자를 갖는다. 이 인자는 직렬화 or 복원할 프로퍼티 목록을 지정할 수 있다. 직렬화하거나 문자열로 바구는 과정에서 특정 프로퍼티의 값을 바꿀 수도 있다.

## 6.10 객체 메서드
Object.prototype에 정의된 유용한 전역 객체 메서드들이 있다.

### 6.10.1 toString() 메서드
toString() 메서드는 어떠한 인자도 받지 않고, 호출 대상 객체의 값을 어떤한 방식으로든 문자열로 만들어서 반환한다.

자바스크립트는 객체를 문자열로 변환해야 할 때 항상 toString() 메서드를 사용한다.(ex, + 연산자를 사용할 때나 문자열을 인자로 받는 메서드에 객체를 전달할 때 등)

기본적으로 객체의 클래스를 판별할 때를 제외하고는 toString() 메서드가 제공하는 정보는 그다지 유용하지 않기 때문에 많은 클래스가 고유한 toString() 메서드를 정의한다.

### 6.10.2 toLocaleString() 메서드
모든 객체는 toLocaleString() 메서드를 가지고 있다. 이 메서드는 객체의 지역화(localized)된 문자열 표현을 반환한다. 객체에 기본으로 정의된 toLocaleString()은 단순히 toString()을 호출한 결과를 반환한다. 그러나 Date와 Number 클래스는 숫자와 날자, 시간을 지역화된 형식을 출력하기 위해 맞춤형 toLocaleString()을 정의하고 있고 배열도 마찬가지다.

### 6.10.3 toJSON() 메서드
Object.prototype()에는 toJSON() 메서드가 정의되어 있지 않다. 하지만, JSON.stringify() 메서드는 직렬화할 객체에 toJSON 메서드가 있는지 찾는다. 있으면 toJSON을 호출되고 결과 값이 원래 객체 대신 직렬화된다.

### 6.10.4 valueOf() 메서드
valueOf() 메서드는 toString() 메서드와 매우 유사하다. 이 메서드는 자바스크립트가 객체를 숫자와 같은 다른 원시 타입으로 변환하려 할 때 호출된다. valueOf() 메서드는 기본적으로 아무런 변환작업을 하지 않기 때문에 몇몇 내장 객체들은 자심나의 valueOf() 메서드를 정의한다.