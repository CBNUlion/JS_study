# 함수
함수는 한번 정의하면 몇 번이든 실행할 수 있고 호출할 수 있는 자바스크립트 코드 블록이다.

자바스크립트에서 함수는 객체이고 프로그램 안에서 조작할 수 있다. 자바스크립트 함수는 다른 함수 내에 중첩되어 정의될 수 있고, 중첩된 함수는 해당 함수가 정의된 유효범위 안이 어떤 변수에도 접근할 수 있다. 이것으로 보아 자바스크립트 함ㅅ는 클로저(closure)인 것을 알 수 있다.

## 8.1 함수 정의하기
함수는 function 키워드에 의해 정의되며, 다음과 같은 구성요소들이 따라온다.
- 함수 이름 식별자 : 변수 이름, 새로 정의된 함수 객체가 할당된다. 함수 정의 표현식에서 이름을 생략할 수 있지만, 명시했다면 그 이름은 해당 함수 몸체 안에서만 참조할 수 있다.
- 쉼표로 구분된 0개 이상의 식별자들과, 이 식별자들을 둘러싼 한 쌍의 괄호(매개변수, 형식인자 : 함수 몸체 내에서 지역 변수처럼 취급)
- 0개 이상의 자바스크립트 문장을 포함하는 한 쌍의 중괄호

함수 정의 표현식에서 함수 이름은 옵션이다. 함수 선언문이 실제로 하는 일은 그 변수에 함수 객체를 할당하는 것이다.

앞 장에서 확인했듯이 함수 선언문은 그 함수를 둘러싼 스크립트나 함수의 맨 위로 끌어올려진다. 함수가 정의된 위치보다 앞서 나오는 코드로부터 호출이 가능하다.
```javascript
//함수 표현식
var f = function ...
//위와 같이 변수 등에 함수가 들어갈 때를 뜻함
```
하지만, 표현식으로 정의된 함수는 호출할 함수를 참조할 수 있는 곳이 필요하기 때문에 변수에 할당되기 전까지는 참조할 수 없다. 즉, 변수 선언은 끌어올려지지만 변수 할당은 그렇지 않다는 것을 알 수 있다. 따라서, 표현식으로 정의된 함수는 정의되는 지점 위에서는 호출할 수 없다.

함수의 대부분은 return 문을 포함하는데, return 문은 함수를 중단하고 다음에 오는 표현식의 값을 호출자에게 반환한다. 표현식이 없거나 return 문을 포함하지 않는 함수라면 최종적으로 undefined를 반환한다.

### 8.1.1 중첩 함수
자바스크립트에서 함수는 다른 함수와 중첩될 수 있다. 중첩 함수에서는 유효 범위(scope) 규칙을 잘 알아야하는데, 중첩된 함수는 해당 함수가 속한 함수(들)의 매개변수와 변수에 접근할 수 있다.

함수 선언문은 진짜 문장이 아니다. 또한, ES에서는 함수 선언문을 최상위 레벨에만 두도록 규정하고 있다. 함수 선언문은 전역 코드 혹은 다른 함수 안에는 등장할 수 있지만, 반복문 내부, 조건문, try/catch/finally 또는 with문 안에는 들어갈 수 없다.
>함수 정의 표현식은 자바스크립트 코드 어디에나 사용할 수 있다.

## 8.2 함수 호출하기
함수를 정의했더라도 함수 몸체의 자바스크립트 코드는 호출이 되어야 실행된다. 다음은 함수를 호출하는 방법이다.
- 일반적인 함수 형태
- 메서드 형태
- 생성자
- call()과 apply() 메서드를 통한 간접 호출

### 8.2.1 함수 호출
함수는 일반적인 함수 형태로 호출되거나 호출표현식, 메서드 형태로 표현된다. 호출 표현식은 함수 객체로 평가되는 함수 표현식과 여는 괄호 콤마로 구분된 0개 이상의 전달인자 표현식, 그리고 닫는 괄호로 구성된다. 이때 함수 표현식이 프로퍼티 접근 표현식이면 메서드 형태이다.

함수가 호출될 때는 각각의 전달인자 표현식이 평가되고, 평가 결과 값이 해당 함수의 전달인자가 된다. 이 값을 이용해 함수 몸체 정의에 등장하는 형식인자 각각에 대응된다.

### 8.2.2 메서드 호출
메서드는 객체의 속성으로 저장된 자바스크립트 함수일 뿐이다. 메서드 호출의 전달인자와 반환 값에 관한 규칙은 일반 함수와 같지만, 함수 호출에 비해 다른 부분이 존재하는데 바로 *호출 컨텍스트*다. 프로퍼티 접근 표현식은 객체와 프로퍼티 이름으로 구성되어 있는데, 메서드 호출 표현식에서는 객체가 호출 컨텍스트가 되므로, this를 통해 객체를 참조할 수 있다.

대부분의 메서드 호출은 프로퍼티 접근 표현식에 점(.)을 사용하지만, 대괄호([])를 사용해도 메서드를 호출 가능하다.
```javascript
o[“m”](x,y);	// o.m(x, y)
a[0](z);		// a[0]을 함수라고 가정
```
복잡한 프로퍼티 접근 표현식도 포함 가능하다
```javascript
f().m();		// f()가 반환한 객체에 있는 메서드 m()을 호출한다.
```
메서드로 사용되는 함수는 메서드의 호출 대상 객체를 암시적 인자로 전달받는다.(무슨 소리?)

>메서드 체이닝(Method Chaining) : 메서드가 객체를 반환하면, 메서드의 반환 값을 후속 호출의 일부로 사용할 수 있다. 이는 단일 표현식만으로 일련의 메서드를 호출할 수 있게끔 한다.

변수와 달리 this 키워드에는 유효범위가 없고 중첩 함수는 호출자의 this 값을 상속하지 않는다. 만약 중첩 함수가 메서드가 형태로 호출되면 그 함수의 this 값은 그 함수의 호출 대상 객체다. 만약  중첩 함수가 함수 형태로 호출되면, 중첩 함수의 this 값은 global 객체(일반모드) 또는 undefined(엄격 모드)이다. 흔히들 하는 실수는 바깥쪽 함수의 호출 컨텍스트를 획득하기 위해 this 값을 사용할 수 있다고 가정하는 것이다. 만약, 바깥쪽 함수의 this 값에 접근하고 싶다면 바깥쪽 함수의 this 값을 별도으 변수로 저장해야 한다.
```javascript
var o = {
    m: function() {			// 객체의 메서드 m
        var self = this;			// this 값을 저장한다.
        console.log(this === o);		// true
        f();				// 중첩 함수 f()
        function f() {
            console.log(this === o);	// false: this는 global or undefined
            console.log(self === o);	// true: 바깥 쪽 함수의 this
        }
    }
};
o.m();
```

### 8.2.3 생성자 호출
함수나 메서드 호출 앞에 new 키워드가 있다면, 그것은 생성자 호출이다. 생성자 호출은 일반 함수와 메서드 호출에 비해 매개변수, 호출 컨텍스트와 반환 값을 다루는 방식이 다르다. 생성자 호출에서 괄호 안에 전달인자 목록이 있다면 우선 전달인자 표현식이 평가되고, 함수와 메서드 호출처럼 생성자 함수에 전달된다. 생성자에 매개변수가 없다면 괄호를 생략하는 것을 허용한다.
```javascript
var o = new Object();
var o = new Object;
// 위의 두 문장은 동일하다.
```
생성자를 호출하면 생성자의 prototype 프로퍼티를 상속받은 새로운 빈 객체가 생성된다. 생성자 함수는 객체를 초기화하고, 새로 생성된 이 객체는 생성자 함수의 호출 컨텍스트로 사용된다. 주의할 것은 생성자 호출이 메서드처럼 보일지라도 메서드가 속한 객체가 아닌 새로 생성된 객체가 호출 컨텍스트로 사용된다는 점이다. 즉, new o.m() 과 같은 표현식에서 o가 호출 컨텍스트로 사용되지는 않는다는 뜻이다.

일반적으로 생성자 함수는 새 객체를 초기화하고, 생성자 함수 몸체의 끝에 이르면 암시적으로 그 객체를 반환한다. 이때 새 객체가 생성자 호출 표현식의 값이다. 만약 생성자가 return 문을 사용하여 명시적으로 어떤 객체를 반환한다면, 반환된 객체가 생성자 호출의 값이 된다.

### 8.2.4 간접 호출
자바스크립트 함수는 객체이고, 모든 자바스크립트 객체와 같이 함수에도 메서드가 있다. 이 중 call()과 apply()는 함수를 간접적으로 호출한다. 두 메서드 모두 호출 때 this 값을 명시적으로 지정할 수 있는데, 이는 어떤 함수든지 특정 객체의 메서드로 호출할 수 있다는 의미다.

call() 메서드는 자신에게 주어진 전달인자를 호출할 함수의 전달인자로 사용한다.

apply() 메서드는 값 배열을 전달인자로 사용한다.

## 8.3 함수 전달인자와 매개변수
자바스크립트에서 함수를 정으할 때는 함수 매개변수 타입, 즉 자료형을 명시하지 않는다. 이번 장에서는 함수 호출 시 해당 함수에 정의된 매개변수보다 적거나 더 많은 인자가 전달되었을 때 어떤 일이 일어나는 지가 이 장의 세부 절에서 설명할 내용이다.

### 8.3.1 todfir 가능한 매개변수
본래 정의된 것보다 적은 수의 전달인자로 함수가 호출되면 나머지 매개변수는 undefined 값으로 설정된다. 하지만, 전달인자를 생략할 수 있도록 함수를 구현하면 편할 때가 있다.

생략 가능한 전달인자를 사용하여 함수를 설계할 때, 생략할 수 있는 인자는 전달인자 목록의 제일 뒤쪽에 두어야 한다. 여러분이 만든 함수를 호출할 프로그래머는 첫 번째 인자를 생략하고 두 번째 인자만 전달할 수는 없다. 함수를 정의할 때 사용하는 주석 /* optional */은, 해당 매개변수를 생략할 수 있음을 강조하기 위한 것이다.

### 8.3.2 가변길이 전달인자 목록: Arguments 객체
함수가 호출될 때 정의된 매개변수보다 더 많은 인자가 전달되면, 매개변수 이름이 붙지 않은 인자 값을 직접적으로 참조할 방법은 없다. Arguments 객체는 이러한 문제에 대한 해결책이다. 함수 내의 arguments 식별자는 해당 호출에 대한 Arguments 객체를 참조한다. Arguments 객체는 유사 배열 객체이고, 이름이 아니라 인덱스 숫자를 통해 함수의 전달인자를 얻어올 수 있다.

전달인자 x 하나만 받는 함수 f에 두 개의 전달인자로 호출한다면, 첫 번째 전달인자는 매개변수 이름 x 또는 arguments[0]을 사용하여 접근 가능하며 두 번째 전달인자는 arguments[1]을 사용해서만 접근할 수 있다. 실제 배열처럼 length 또한 이용 가능하다. Arguments 객체의 한 가지 중요한 용도는 임의 개수의 전달인자를 받는 함수를 작성하는 것이다.
```javascript
function max(/* ... */) {
    var max = Number.NEGATIVE_INFINITY;
    for(var i = 0; i < arguments.length; i++)
        if ( arguments[i] > max) max = arguments[i];
    return max;
}
```
임의 개수의 전달인자를 받을 수 있는 함수를 보통 varadic 함수, variable arity 함수, varargs 함수 등으로 부른다.

varargs 함수라고 할 지라도 전달인자 없이 호출되는 경우를 허용할 필요는 없다. 이름이 붙은 고정 개수의 전달인자 뒤에 임의 개수의 전달인자를 받는 함수를 작성할 때에도, arguments[] 객체는 아주 유용하다. aarguments는 실제로 배열이 아니라 Arguments객체이다. (유사 배열 객체)

Arguments 객체의 배열 원소는 각 매개 변수의 별칭과도 같다.
```javascript
function f(x) {
    console.log(x);			// 전달 받은 값 출력
    arguments[0] = null;		// x의 값 또한 변경
    console.log(x);			// 이제 null을 출력
}
```
위와 같은 방식은 ES5 엄격 모드에서는 제거되었다.

**callee와 caller 속성**
Arguments 객체는 배열 원소 외에도 callee와 caller 프로퍼티를 정의하고 있다.

caller는 비표준이지만 많은 자바스크립트 구현체에 보편적으로 구현된 프로퍼티이며, 이 함수를 호출한 함수를 참조한다.
caller 프로퍼티는 호출 스택에 접근할 수 있도록 해주고, callee 프로퍼티는 이름없는 함수를 재귀적으로 호출하는데 유용하다.
```javascript
var factorial = function(x) {
    if (x <= 1) return 1;
    return x * arguments.callee(x-1);
};
```

### 8.3.3 객체의 프로퍼티를 전달인자로 사용하기
함수에 매개변수가 많다면 프로그래머는 인자의 올바른 순서를 기억하기 어렵다. 따라서, 보통 전달인자를 순서에 상관없이 이름/값의 쌍으로 함수에 전달하는 편이 효과적일 수 있다.

### 8.3.4 전달인자 형식
자바스크립트 메서드의 매개변수에는 정의된 형식도 없고, 함수에 전달한 값에 대해서 자료형 검사도 하지 않는다. 따라서, 함수 인자에 해당 인자를 잘 설명하는 이름을 선택하거나 주석에 인자의 자료형을 명시하면 코드를 문서화하는 데 도움이 된다. 생략가능한 인자에는 ‘optional’이라는 단어를 주석에 포함시키면 된다.

자바스크립트는 필요에 따라 자유롭게 자료형 변환을 수행하기 때문에 매개 변수의 형식이 맞지 않아도 에러가 발생하지 않을 수 있다. 하지만, 필요한 자료형의 매개변수를 받을 때 자료형을 검사하는 코드를 추가할 가치가 있다. 모르는 오류보다는 알고 있는 오류를 띄우는 게 좋다.

## 8.4 값으로서의 함수
함수의 가장 중요한 특징은 정의될 수 있고 또 호출될 수 있다는 점이다. 자바스크립트에서의 함수는 문법일 뿐만 아니라 값이기도 한데, 이는 함수가 벼수에 할당될 수 있고 객체의 프로퍼티나 배열 원소로 저장될 수도 있으며, 다른 함수의 인자로 전달될 수도 있고, 기타 여러 방식으로 사용될 수 있음을 뜻한다.

자바스크립트의 함수는 객체의 프로퍼티의 역할을 할 수 있는데, 이를 객체의 메서드라고 한다.

### 8.4.1 자신만의 함수 프로퍼티 정의하기
자바스크립트에서 함수는 특별한 종류의 객체이며 프로퍼티를 가질 수 있다. 오직 함수에만 사용하는 정보는 그 함수 객체의 프로퍼티에 저장하는 편이 더 낫다.
```javascript
// 실제 uniqueInteger 함수 정의문 앞에서 이렇게 할당이 가능하다. 함수의 범위
uniqueInteger.counter = 0;

function uniqueInteger() {
    return uniqueInteger.counter++;
}
```

## 8.5 네임스페이스로서의 함수
자바스크립트는 함수 단위의 유효범위를 갖는다. 함수 내에서 정의하는 변수는 네임 스페이스 자체가 함수 내에 있기 때문에 전역 네임스페이스를 어지럽히지 않는다.
```javascript
function mymodule() {
    // 모듈에서 사용하는 어떤 변수건 이 함수의 지역 변수다.
    // 따라서 전역 네임스페이스를 어지럽히지 않는다.
}
```
위의 코드는 ‘mymodule’인 단 하나의 전역 변수만 정의되었다. 다른 방법으로는 익명 함수를 정의하고 호출하는 단일 표현식을 이용하는 방법도 있다.

>괄호가 꼭 필요하지 않는 상황에서도, 정의하자마자 호출할 함수를 괄호로 둘러싸는 건 관용적인 방식이다.

(p 255 예제 8-3 이해 안됨)

## 8.6 클로저
자바스크립트는 어휘적 유효범위(lexical scoping)을 사용한다. 함수를 호출하는 시점에서의 변수 유효범위가 아니라, 함수가 정의된 시점의 변수 유효범위를 사용하여 함수가 실행된다는 뜻이다. 자바스크립트 객체는 내부 상태에 함수 자체의 코드뿐만 아니라 현재 유효범위 체인에 대한 참조도 포함하고 있다. 함수 객체와 함수의 변수가 해석되는 유효범위(변수 바인딩의 집합)를 아울러 **클로저(closure)**라고 일컫는다.

모든 자바스크립트 함수는 클로저인데, 함수는 객체이며 함수 자신과 관련된 유효범위 체인을 사용하여 호출되고, 클로저가 개입되었는지의 여부는 중요하지 않다.

클로저를 이해하는 첫 걸음은 중첩 함수의 어휘적 유효범위 규칙을 확인해보는 것이다.
```javascript
var scope = “global scope:l
function checkscope() {
    var scope = “local scope”;
    function f() { return scope; }
    return f();
}
checkscope()		// => ‘local scope‘
```

다음 코드 결과를 예상해보자
```javascript
var scope = “global scope”;
function checkscope() {
    var scope = “local scope”;
    function f() { return scope; }
    return f;
}
checkscope()()		// => ‘local scope‘
```
위와 같이 나오는 이유는 유효범위의 기본 규칙을 중요시 여기기 때문이다. 함수가 정의된 시점에서 어떤 유효 값을 가지고 있는 지가 중요하다.

>클로저 : 자신을 정의한 바깥쪽 함수에 바인딩된 지역 변수(그리고 전달인자)를 포착한다.

자바스크립트 객체의 유효범위 체인은 중첩 함수가 정의되어 있다면 유효범위 체인에 그 참조값이 남아있기 때문에 클로저를 이용할 수 있게 된다.(유효범위 체인은 객체와 바인딩된 변수를 참조)

함수 내에서 같은 내부 변수는 여러 클로저가 공유할 수 있다. 즉, 같은 함수 안에 정의된 중첩 함수들은 같은 유효범위 체인을 공유한다.
```javascript
function counter() {
    var n = 0;
    return {
        count: function() { return n++; },
        reset: function() { n = 0; }
    };
}
var c = counter(), d = counter(); 	// 두 개의 카운터를 생성한다.
c.count()				// => 0
d.count()				// => 0: 서로 독립적
c.reset()
c.count()				// => 0
d.count()				// => 1
```
위를 보며 알아야할 것은 두 가지가 존재한다.
1. 두 메서드가 ‘privat variable’, 내부 변수 n 을 공요한다는 것
2. counter()를 호출할 때마다 새로운 유효범위 체인과 새로운 내부 변수가 생성되는 점

클로저 기법과 getter/setter 프로퍼티를 결합할 수 있다는 것도 굉장히 좋은 사실이다. 내부 상태를 다루는 데 일반 객체 프로퍼티 대신 클로저를 사용할 수 있다.

클로저를 사용할 때 아래와 같은 여러 개의 클로저를 사용함에 있어 실수를 주의해야한다.
```javascript
function constfuncs() {
    var funcs = [];
    for(var i = 0; i < 10; i++)
        funcs[i] = function() { return i; };
    return funcs;
}
var funcs = constfuncs();
funcs[6]()		// => 인덱스의 값이 어떤 값이 들어가든(0~10) 모두 10을 반환한다.
// 위의 코드는 클로저들이 변수 i에 대한 접근을 공유하기 때문이다.
```

```javascript
function constfunc(v) { return function() { return v; }; }

var funcs = [];
for(var i = 0; i < 10; i++) funcs[i] = constfunc(i);

funcs[5]()	// => 5
```
위의 코드와 아래 코드의 차이 점은 클로저의 변수 공유에 관한 부분이다 위의 코드는 모든 클로저가 변수 i를 공유하기 때문에 같은 값이 나오는 것이고 아래 코드는 클로저들은 각각의 v의 값을 바라보고 있기 때문에 별개의 값이 나올 수 있는 것이다. 위의 코드는 클로저와 연관된 유효범위 체인이 ‘살아 있다’는 사실을 기억해야한다. 중첩 함수는 유효범위에 대한 내부 사본이나 변수 바인딩의 스냅샵 따위는 만들지 않는다.

두 번째로 유의해야할 점은 this는 자바스크립트 키워드이지 변수가 아니라는 점이다. 앞에서 말했던 것처럼 함수 호출에는 this 값이 있고, 바깥쪽 함수가 this 값을 별도의 변수로 저장하지 않으면 클로저는 바깥쪽 함수의 this 값에 접근할 수 없다. arguments 또한 클로저가 사용하려고 하면 따로 변수로 저장을 해줘야한다.

## 8.7 함수 프로퍼티, 메서드, 생성자
자바스크립트 프로그램에서 함수는 일종의 값이다. 함수는 정말 독특한 객체이고 그렇기 때문에 프로퍼티와 메서드도 가지고 있다. 또한, Function() 이라는 생성자도 갖고 있다.

### 8.7.1 length 프로퍼티
arguments.length는 함수에 실제로 전달된 인자의 개수다. 하지만, 함수 자체의 length 프로퍼티는 의미가 다르다. 이 프로퍼티는 함수를 정의할 때 명시한 인자 개수(arity)를 반환한다.
```var a = function(x, y) {    console.log(arguments.length);	// => 전달받은 인자 출력}

a(x);					// => 1
a.length;				// => 2
```

### 8.7.2 prototype 프로퍼티
함수에는 prototype 프로퍼티가 있는데, 이 프로퍼티는 프로토타입 객체를 참조한다. 함수들은 서로 다른 프로토타입 객체를 가지고 있다. 함수가 생성자로 사용될 때, 새로 생성된 객체는 함수의 프로토타입 객체로부터 프로퍼티들을 상속받는다.

### 8.7.3 call()과 apply() 메서드
call()과 apply()는 어떤 함수를 다른 객체의 메서드인 것처럼 간접적으로 호출할 수 있도록 한다. 이들의 첫 번째 인자는 호출되는 함수와 관련이 있는 객체다. 이 첫 번째 인자는 호출 컨텍스트고 함수 몸체에서 **this 키워드의 값**이 된다.
```javascript
// 함수 f를 o의 메서드로 호출f.call(o);
f.apply(o);

//아래 코드와 유사하다.
o.m = f;
o.m();
delete o.m;
```
ES 5의 엄격 모드에서 call() 또는 apply()의 첫 번째 인자는 함수 내에서 this의 값이 되는데, 그 값이 원시 값이든 null이든 undefined든 상관없다. ES 3이나 일반 모드에서는, null이나 undefined 값은 전역 객체로 바뀌고 원시 값은 이에 상응하는 래퍼 객체로 바뀐다.

call()의 첫 번째 호출 컨텍스트 다음에 있는 모든 인자는 호출되는 함수로 전달된다.
```javascript
f.call(o, 1, 2);		// 객체 o의 메서드로 f를 사용하고 메서드에 1, 2를 전달한다.
```

apply()로 call()과 같이 동작시키려면 배열 형태로 인자를 보내야한다.
```javascript
f.apply(o, [1,2]);
```
만약, 함수가 임의 개수의 인자를 받로고 정의되었다면, apply() 메서드는 임의 길이의 배열을 사용하여 해당 함수를 호출할 수 있다. 예를 들어 숫자들로 이루어진 배열에서 가장 큰 숫자를 찾으려면, apply() 메서드를 사용하여 배열의 각 요소를 Math.max()에 전달할 수 있다.
```javascript
var biggiest = Math.max.apply(Math, array_of_numbers);
```

apply()는 실제 배열과 마찬가지로 유사 배열 객체와도 잘 작동한다. 특히, arguments 배열을 직접 apply()에 넘김으로써, 다른 함수를 호출할 때 현재 함수에 전달된 인자와 같은 인자를 전달할 수 있다.

### 8.7.4 bind() 메서드
bind()의 주요 목적은 함수와 객체를 서로 묶는 것이다. 함수 f의 bind() 메서드를 호출하면서 객체 o를 전달하면, bind() 메서드는 새로운 함수를 반환한다. 반환된 새 함수를 호출하면, 원래 함수 f가 o의 메서드로 호출된다.
```javascript
function f(y) { return this.x + y; }
var o = { x : 1 };
var g = f.bind(o);
g(2)			// => 3
```

ES 5에서 bind() 메서드는 파셜 어플리케이션(Partial Application)을 구현하는데, bind()에 전달하는 인자 중 첫 번째 이후의 모든 인자는 this 값과 함께 해당 함수의 인자로 바인딩된다.
```javascript
var sum = function(x, y) { return x + y };
var succ = sum.bind(null, 1);			// x = 1 로 바인드 된다. 하나의 인자만 더 요구된다.

succ(2)						// => 3
```

ES 5 bind() 특징
1. 실제 bind() 메서드는 함수 객체를 length프로퍼티와 함께 반환하는데, 이 length 프로퍼티는 바인딩된 함수에 정의되어 있는 인자 개수에서 바인딩된 인자의 수를 뺀 값이다.
2. Es 5의 bind() 메서드는 함수 생성자에 대한 파셜 애플리케이션으로 사용될 수 있다. 만약,bind()에 의해 반환된 함수가 생성자로 사용되면, bind()에 전달했던 this는 무시되고 원본 함수가 생성자로 호출되며, 이때 이미 바인딩된 인자들이 원본함수 생성자에 전달된다.

bind() 메서드가 반환하는 함수에는 prototype 프로퍼티가 없다. 또한 바인딩된 함수를 생성자로 사용하여 만든 객체는 원본 함수의 prototype을 상속받는다. 마지막으로 바인딩된 생성자에 instanceof 연산자를 사용한 결과는 원본 함수에 instanceof 연산자를 사용한 경우와 같다.

### 8.7.5 toString() 메서드
자바스크립트 객체와 마찬가지로 함수도 toString() 메서드를 가지고 있다. 이 메서드 구현체들은 함수의 전체 소스 코드를 반환한다. 내장 함수의 경우는 보통 함수 몸체로 “[native code]”와 같은 내용의 문자열을 반환한다.

### 8.7.6 Function() 생성자
함수를 정의하는 또 하나의 방법으로는 Function() 생성자가 있다.
```javascript
var f = new Function(“x”, “y”, “return x*y;”);
// 아래와 동일 한코드이다.
var f = function(x, y) { return x*y; }
```
Function() 생성자는 임의 개수의 문자열 인자를 요구하며 마지막 인자는 함수 몸체의 텍스트다. 또한 세미콜론으로 구분된 임의의 자바스크립트 구문을 포함할 수 있다.

Function() 생성자는 생성하려는 함수의 이름을 지정하는 어떤 인자도 받지 않는다. 함수 리터럴과 마찬가지로 Function() 생성자는 익명 함수를 생성한다. 

Function 생성자의 중요한 점
- Function() 생성자는 동적으로 자바스크립트 함수를 생성하고 실행 시간에 컴파일되는 것을 가능케 한다.
- Function() 생성자는 생성자가 호출될 때마다 함수 몸체를 분석(parse)하여 새로운 함수 객체를 생성한다. 루프 내부 또는 자주 호출되는 함수 내에서 생성자를 호출한다면 비효율적이다. 하지만, 중첩된 함수나 함수 정의 표현식은 루프 내에 잇더라도 매번 재컴파일되지는 않는다.
- Function() 생성자와 관련하여 매우 중요한 점은 함수 생성자가 생성하는 함수는 어휘적 유효범위(lexical scoping)를 사용하지 않는다는 것, 함수 생성자가 생성한 함수는 언제나 최상위 레벨 함수로 컴파일된다.
```javascript
var scope = “global”;
function constructFunction() {
    var scope = “local”;
    return new Function(“return scope”);
}

constructFunction()();		// ’global’
```
사용할 일은 거의 없다..

### 8.7.7 호출 가능한 객체
함수에도 유사 배열 객체와 비슷한 개념이 있다. 호출 가능 객체는 함수 호출 표현식을 통해 호출할 수 있는 객체다. 모든 함수는 호출 가능 객체이지만, 호출 가능 객체가 모두 함수는 아니다.

호출 가능 객체의 일반적인 형태는 RegExp 객체다. 많은 브라우저에서 regExp 객체의 exec()메서드를 호출하는 대신, RegExp 객체를 직접적으로 호출할 수 있다.(사용 안하는 것이 좋다.)

객체가 진짜 함수 객체(함수 메서드를 가지고 있는 지)인지를 알아보고 싶다면 class 속성을 테스트 해보면된다.
```javascript
function isFunction(x) {
    return Object.prototype.toString.call(x) === “[object Function]”;
}
```

## 8.8 함수형 프로그래밍
자바스크립트가 함수를 객체로 취급할 수 있다는 말은 자바스크립트에서도 함수형 프로그래밍 기법을 사용할 수 있다는 의미다. 이 장에서는 자바스크립트 함수가 그 정도로 강력하다는 것을 살펴볼 것이다.

### 8.8.1 함수로 배열 처리하기
숫자로 이루어진 배열의 평균과 표준 편자를 구할 때의 비함수형 프로그래밍 코드
```javascript
var data = [1, 1, 3, 5, 5];

var total = 0;
for(var i = 0; i < data.length; i++) total += data[i];
var mean = total/data.length;				// 3

var total = 0;
for(var i = 0; i < data.length; i++) {
    var deviation = data[i] - mean;
    total += deviation * deviation;
}
var stddev = Math.sqrt(total/(data.length-1));
```

자바스크립트의 map(), reduce() 를 사용한다면 더 간단해진다.
```javascript
var sum = function(x, y) { return x+y; };
var square = function(x) { return x*x };

var data = [1, 1, 3, 5, 5];
var mean = data.reduce(sum)/data.length;
var deviations = data.map(function(x) { return x-mean; });
var stddev = Math.sqrt(deviations.map(square).reduce(sum)/(data.length-1));
```

### 8.8.2 고차 함수
고차 함수(higher-order function)는 하나 이상의 함수를 인자로 받고, 새 함수를 반환하는 함수다.

((이 부분은 전부 이해가 안된다. 다시 공부0)

### 8.8.3 함수의 파셜 애플리케이션
bind() 메서드는 대상 함수르 호출하기 위해 부분적으로 인자를 적용할 때 부분 인자를 ‘왼쪽’에 적용하는데, 이는 bind()에 넘긴 인자들은 대상 함수에 전달되는 인자 목록의 시작점에 위차한다는 뜻이다.

((코드 부분 지금은 이해 되었지만 나중에 분명 까먹을 듯))

### 8.8.4 메모이제이션
함수형 프로그래밍에서는 이전 결과를 캐시해두는 캐싱 방식을 메모이제이션(memiozation)이라고 부른다.

memoize() 함수는 캐시 값을 저장하는데 사용할 새 객체를 생성하고, memoize()의 지역 변수에 이 객체를 할당한다.

((이거 굉장히 유용할듯.. 좋다))