# 5장 문장
4장에서는 표현식을 구절로 설명했다. 이번 장에서는 문장, ‘문’은 자바스크립트 문장 명령어다. 자바스크립트의 문장은 세미콜론(;)으로 끝난다. 표현식은 어떤 값을 생성하기 위해 평가되지만, 구문은 어떤 일을 하기 위해 실행 된다.

‘무언가 정말로 일어나게’ 만드는 한 가지 방법은 부수 효과가 있는 표현식을 실행하는 것이다. 할당문이나 함수 호출처럼 부수 효과가 있는 표현식은 독립적인 문장으로 사용할 수 있는데, 그런 것을 표현식 문장 즉 표현문이라고 한다. 이외에도 선언문장(선언문) 등이 있다.

자바스크립트 프로그램은 순서대로 실행되는 문장들의 집합이다.
기본적으로 문장들을 순서대로 실행하지만 ‘무언가 정말로 일어나게’ 만드는 또 다른 방법은, 이 기본 순서를 바꾸는 것이다. 이는 제어 구조를 통해 일어난다.

## 5.1 표현문
자바스크립트 문장 중에서 가장 간단한 형태는 부수효과가 있는 표현문이다.
할당문이 대표적인 표현문 중 하나다.
```javascript
greeting = “Hello ” + name;
I *= 3;
```

증감 연산자들은 할당문과 관계가 있다. 이들은 변수 값 자체를 바꾸는 부수효과를 통해 변수에 값을 할당한 것과 같은 효과를 보인다
```javascript
counter++;
```

delete 연산자는 객체 프로퍼티 삭제를 하는 부수효과가 있다.

표현문의 다른 종류로 함수 호출이 있다.
```javascript
alert(greeting);
window.close();
```
함수 호출은 표현식이지만 웹 브라우저에 영향을 주는 부수효과가 있으며, 여기서는 문장으로 사용되었다. 부수효과가 없다면 함수가 표현식의 일부거나 또는 할당문의 일부가 아닌 이상 호출하는 의미가 없다.

## 5.2 복합문과 빈 문장
하나의 표현식 안에 여러 표현식을 합칠 때에는 쉼표(,) 연산자를 사용한다. 이와 유사하게 문장 블록은 여러 문장을 하나의 복합문으로 묶는다.

문장 블록에 대해 알아야할 점
1. 문장 블록은 세미콜론으로 끝나지 않는다. 블록 내부의 기본 문장들은 세미콜론으로 끝나지만 블록 자체는 아니다.
2. 블록 안에 있는 구문은 구문들을 감싸는 중괄호 위치를 기준으로 들여쓰기를 해야한다. 필수는 아니다
3. 자바스크립트에는 블록 단위의 유효범위가 존재하지 않기 때문에, 구문 블록 안에 선언된 변수는 블록뿐 아니라 블록 밖에서도 접근할 수 있다.

여러 문장을 문장 블록으로 합치는 것은 자바스크립트에서는 매우 일반적이다.

자바스크립트 문법은 대체로 하나의 하위문을 허용한다. 하나의 하위문에 블록을 이용해 얼마든지 많은 문장을 넣을 수 있는 것이다.

빈 문장은 위와 반대로 하나의 문장이 있어야할 곳에 아무런 문장도 두지 않을 수 있다
```javascript
;	//세미콜론 하나
```
빈 문장은 몸체가 비어있는 루프를 만들고자 할 때 유용
```javascript
// 배열 a를 초기화한다.
for(i = 0; i<a.length; a[i++] = 0) ;
```
이 루프에서는 a[i++] = 0 표현식으로 배열이 초기화된다.

이러한 빈 문장 사용할 때는 코드에 고의로 사용했다는 설명을 주석으로 넣어주는 것이 좋다
```javascript
for(i = 0; i<a.length; a[i++] = 0) /* 비어 있음 */;
```

## 5.3 선언문
var와 function은 각각 변수와 함수를 선언하고 정의하는 선언문이다. 선언문은 변수나 함수 이름 같은 식별자를 정의한다. 선언문은 그 자체로 많은 일을 하지 않으나, 프로그램 내의 문장들의 의미를 완전학 하는 중요한 역할을 가진다.

### 5.3.1 var
var 문은 하나 또는 그 이상의 변수를 선언
>사용법 : var 변수_1 [ = 값_1] [ ,..., 변수_n [= 값_n]]
var 키워드 다음에는 선언될 변수들이 쉼표로 구분된다. 각 변수는 초기 값을 지정하기 위한 표현식을 가질 수 있다.
```javascript
var x = 2, y = x*x;
var x = 2,
     f = function(x) { return x*x },
     y = f(x);
```

함수 내부에서 사용하는 var문은 지역변수를 정의, 지역 변수는 해당 함수 내에서만 사용할 수 있다. var 문이 최상위 코드로 사용된다면, 이는 전역 변수를 선언한 것이다.

다른 전역 프로퍼티와 달리 var로 선언된 프로퍼티는 delete로 삭제할 수 없다.

var 문에서 변수에 초기 값 지정 하지 않을 경우 undefined로 자동 할당.

스크립트나 함수 안에서 선언된 변수는 해당 스크립트나 함수 전체에 걸쳐 유효, 그러나, 초기화는 var문이 선언된 시점에서 발생하고 그 전까지 변수 값이 undefined가 된다.
```javascript
function test() {
    console.log(y);	// undefined
    var y = 2;		//y 선언
    console.log(y);	// 2
}
```
var 문은 for문 안에서도 사용할 수 있다.

### 5.3.2 function
함수를 표현하는 키워드이다.
```javascript
var f = function(x) { return x+1; }		// 변수에 함수를 할당하는 표현식
function f(x) { return x+1; }			// 변수 이름을 포함한 문장
```

**함수 이름**은 선언되는 함수의 이름이 될 식별자. 함수의 몸체는 하나 이상의 자바스크립트 문장들로 구성되어있다. 이 문장들은 함수가 정의될 때 실행되지 않고 호출될 경우를 위해 새로운 함수 객체와 연결한다.

함수 선언문은 자바스크립트 최상위 단계 코드에서 나타날 수도 있고, 다른 함수 내에 중첩될 수도 있다. 함수가 다른 함수 속에 중첩될 때는, 함수 내에서 최상위 단계에 위치해야 한다.

즉, if문이나 while문 등의 다른 문장 안에 있을 수 없다. 위치 제약으로 인해 ES 명세에는 함수 선언을 진정한 문장으로 분류하지 않는다.

함수 선언문은 함수 이름을 포함한다는 점에서 함수 정의 표현식과는 차이가 있다. 둘 다 새 함수 객체를 만들지만, 함수 선언문은 함수 이름을 변수로 선언 한 후 이 변수에 함수객체를 할당.(위의 예제 확인)

var를 이용한 함수 선언문은 함수의 이름과 본문 모두 유효범위 최상단으로 끌어올린다. 이때 스크립트 내의 모든 함수 또는 함수의 중첩 함수는 다른 코드가 실행되기 전에 선언된다.(함수 변수의 유효범위와 유사)

## 5.4 조건문
특정 표현식의 값에 따라 문장을 실행하거나 건너뛴다. 이러한 문장을 **분기**라고 한다.

### 5.4.1 if
if문의 조건식 좌우에는 반드시 괄호가 와야한다. 자바스크립트 문법은 if 키워드와 괄호로 둘러싼 표현식 다음에는 하나의 문장만 올 수 있다고 명시하지만 문장 블록을 사용하면 여러 구문을 하나로 인식하므로 여러 문장을 사용할 수 있다.

중첩 if 문을 사용할 경우 else 문이 적절한 if문에 속하도록 각별히 유의해야한다. 보통 중괄호를 이용해 구분한다.

>많은 프로그래머가 if문과 else문의 몸체가 단 하나의 문장이라도 중괄호로 묶는 습관을 익히고 있다.(while문과 같은 반복문도 마찬가지)

### 5.4.2 else if
```javascript
pass
```

### 5.4.3 switch
if 문을 이용하는 것이 언제나 최선은 아니다. 모든 분기가 동일한 표현식의 값에 의해 결정될 때 switch문을 사용한다.

switch문은 코드 블록의 여러 위치에 레이블을 붙인다. 레이블을 붙일 때 case 키워드를 사용한다. 이때, case의 레이블은 이름이 아니라 표현식이다.

switch문이 실행되면 표현식의 값을 계산하고 값에 대응하는 case 레이블을 찾는다.(이때 내부적으로 === 연산자를 사용한다.) 대응하는 레이블을 찾으면 해당 코드 블록을 실행시키고 없을 경우 default: 레이블을 찾는다. 없다면 모든 코드를 pass 한다.

각 레이블을 구분할 때 break 키워드를 사용한다. 사용하지 않을 경우 해당 레이블부터 모든 레이블이 실행된다.

평가 순서는 switch 표현식 > case문 평가 > 일치 여부를 일치(엄격한 동치) ===를 통해 판단.

default를 보통 가장 마지막에 적지만 블록 어디에서 사용되든 무관하다.

## 5.5 루프
자바스크립트의 루프문
1. while
2. do/while
3. for
4. for/in

루프문은 배열을 순회할 때도 쓰인다.

### 5.5.1 while
while문의 작동은 먼저 **표현식**을 평가하는 것으로 시작하는데 이를 이용해 무한루프도 만들 수 있다.

### 5.5.2 do/while
while과 다르게 끝에 세미콜론을 붙인다. 또한 문장이 한번은 실행이 된다는 것이 특징이다.

### 5.5.3 for
while문 보다 편리하게 루프를 만들 수 있다. for문을 사용할 때는 특정 패턴을 알고 있을 때 사용한다.

매회 돌 때마다 변하는 변수가 다수일 수도 있다.
```javascript
var i, j;
for(i = 0, j = 10 ; i < 10 ; i++, j--);
```

보통 for문에는 숫자형을 루프 변수를 사용하지만 연결리스트 자료구조를 순회하고 리스트의 마지막 객체를 반환하는 코드로 다른 방식을 확인할 수 있다.
```javascript
function tail(o) {		// 링크드 리스트 마지막 객체 o를 반환
for(; o.next; o = o,next) /* 비어 있음 */ ;
				// o.next가 true로 평가되면 계속 순회
return o;
}
```

### 5.5.4 for/in
for/in문은 for 키워드를 사용하지만, 일반적인 for와는 다르다.

객체로 평가되는 표현식에 대한 순회가 가능하다(배열도 역시 가능하다)
```javascript
 /* 배열을 순환하는 for/in 문 */
for(var i = 0; i < a.length; i++)
	console.log(a[i]);
```
```javascript
/* 객체의 프로퍼티를 순회하는 for/in 문 */
for(var p in o)		//변수 p에 객체 o가 가진 프로퍼티 이름을 할당
	console.log(o[p]);
```

for/in문은 먼저 객체 표현식을 평가한다, 표현식이 null이나 undefined로 평가되면 루프를 중단하고 문장을 실행한다. 만약 표현식이 원시 갓으로 평가되면 해당 값은 값과 상응하는 Wrapper객체로 바뀐다. 이 외의 표현식은 객체로 평가된다. 인터프리터에서 루프가 매회 반복되기 전 객체의 각 프로퍼티 이름을 변수에 할당한다.

for/in루프에서 사용하는 변수는 할당 표현식의 좌변에 적합하게 평가되는 표현식을 사용할 수 있다. 표현식은 루프가 돌 때마다 평가되는데, 매번 다르게 평가될 수 잇다.
```javascript
/* 객체의 모든 프로퍼티 이름을 배열에 복사하는 코드 */
var o = (x:1, y:2, z:3);
var a = [?], i = 0;
for(a[i++] in o) /* 비어 있음 */;
```

자바스크립트이 배열은 단순히 특별한 종류의 **객체**에 해당한다. 배열 역시 같은 방식으로 프로퍼티를 열거 할 수 있다.
 ```javascript
for(i in a) console.log(a);	//a는 이전 예제의 배열
```

자바스크립트 코어에 정의된 다양한 내장 메서드들은 일반적으로 열거할 수 없다. 하지만, 사용자가 임의로 정의한 프로퍼티와 메서드들은 모두 열거 가능하다. (ES5에서는 사용자 정의 프로퍼티/메서드도 열거할 수 없다)

### 프로퍼티 열거
ES 명세에는 for/in 루프가 객체의 프로퍼티 열거하는 순서를 명시하지 않고 있다. 하지만 대부분 주요 브라우저 벤더의 자바스크립트 구현체는 프로퍼티들이 정의된 순서대로 열거 하고 있다. 가장 오래전에 정의된 프로퍼티가 처음 열거된다.

만약, 객체가 객체 리터럴로 생성되었을 경우에는 열거 순서가 리터럴에 명시한 프로퍼티 순서와 같다.

아래의 조건에 해당하는 객체의 프로퍼티 열거 순서는 구현체마다 다르며 호환되지 않는다.
1. 열거 가능한 프로퍼티를 상속받는다.
2. 정수 배열 인덱스를 프로퍼티로 갖는다.
3. 객체가 가진 기존 프로퍼티를 delete로 삭제했다.
4. 객체가 가진 기존 프로퍼티를 바꾸기 위해 Object.defineProperty()나 유사 메서드를 사용했다.

일반적으로 상속된 프로퍼티들은 상속받지 않은 ‘고유’ 프로퍼티들 다음에 열거된다.
객체가 여러 프로토 타입에서 프로퍼티들을 상속받을 경우 체인 내 각 프로토타입 객체가 가진 프로퍼티들이 생성된 순서로 열거, 일부 배열 구현체에서는 숫자 순서대로 열거될 수도 있다.

## 5.6 점프문
인터프리터가 점프문을 만나면 소스 내의 특정 위치로 건너뛴다. 자바스크립트는 문장에 이름이나 레이블을 붙일 수 있고, 점푸문은 지정된 루프나 레이블이 붙은 다른 문장을 식별할 수 있다.

### 5.6.1 레이블
어떤 문장에라도 그 압에 식별자 이름과 콜론(:)을 넣음으로써 레이블을 붙일 수 있다. 어떤 문장에 레이블을 붙이면 프로그램의 다른 곳에서 그 문장을 참고할 수 있는 이름이 생긴다. 레이블은 보통 루프나 조건문같이 몸체가 있는 문장에 쓰는 것이 유용하다
```javascript
mainloop: while(token != null) {
//코드
continue mainloop;		//다음 반복 진행
//코드
}
```

예약어를 제외한 모든 자바스크립트 식별자는 레이블이 될 수 있다. 레이블이 속한 이름공간은 변수나 함수의 이름공간과는 달라서 변수나 함수 이름과 같은 식별자를 레이블로 사용 가능하다. 문장 레이블은 레이블이 적용될 문장과, 그 하위 문장 들에만 유용하다. 어떤 문장은 해당 문장을 포함하는 문장과 같은 레이블을 가질 수 없다. 두 문장 사이에 포함관계가 없으면, 두 문장은 같은 레이블을 사용할 수 있다. 레이블이 붙은 문장에도 레이블을 붙일 수 있다.

### 5.6.2 break
현재 진행하고 있는 가장 안쪽의 루프 혹은 switch 문에서 즉시 빠져나올 때 사용한다.

자바스크립트에서는 break문 뒤에 레이블이 따라올 수 있다(콜론(:) 없이 식별자만 사용한다)
```javascript
break labelname;
```
break문을 레이블과 함께 사용하면, 해당 레이블이 붙은 문장 블록의 끝으로 이동하면서 종료한다. 해당 레이블이 붙은 문장 블록이 없으면 오류가 발생한다. break문에 레이블을 사용할 경우, 어떤 블록 밖으로도 벗어날 수 있다. 단순히 레이블을 붙일 목적으로 중괄호 두 개만 이용해 정의한 문장 블록이 될 수도 있다.

break문과 레이블 사이에는 줄바꿈을 허용되지 않는다. break문을 레이블과 함께 쓰는 형식은 중첩된 루프나 switch문에서 빠져나올 위치가 가장 안쪽 문장이 아닌 경우이다.

### 5.6.3 continue
break와 비슷하지만 루프를 빠져나오는 것이 아닌 새로운 반복을 시작하는 키워드이다. continue문 또한 레이블과 함께 사용될 수 있다. continue문은 레이블 사용 여부와 관계 없이 항상 루프의 몸체 내부에서만 사용되어야 한다.

continue문은 루프 종류에 따라 다른 일이 일어난다.
- while 루프에서는 루프의 시작 부분에 지정된 ‘표현식’을 다시 테슽트한다.
- do/while 루프에서는 일단 루프의 끝까지 건너뛴다. 그리고 루프 조건을 다시 테스트한다.
- for 루프에서는 ‘증감’ 표현식을 평가한 후, ‘테스트’ 표현식을 테스트한다.
- for/in 루프에서는 다음 차례의 프로퍼티 이름을 루프 시작에서 지정된 변수에 할당한 후 다시 루프를 시작한다.

break문과 마찬가지로 continue문 역시 중첩된 루프 안에서 레이블과 함게 쓰이는 형식으로 사용될 수 있다. 재시작하려는 루프가 continue문을 포함하는 루프 바깥에 있을 때 쓴다.

### 5.6.4 return
함수 호출 표현식의 값, 즉 함수에서 반환하는 값을 지정하는데 쓰인다. return 문은 오직 함수 몸체 내부에서만 나타날 수 있다. 만약, 함수 내에 return 문이 없다면 함수 몸체의 끝에 도달할 때까지 모든 구문을 실행하고 호출한 지점으로 돌아가는데 이때 함수 호출 표현식의 값은 undefined가 된다.

함수 실행 중 return 문이 실행되면 남은 문장이 있어도 함수를 호출한 지점으로 돌아간다.

### 5.6.5 throw
‘예외’란 예외적인 상황이나 에러가 발생했음을 가리키는 신호다. 예외를 **발생시키는 것(throw)**은 그런 에러나 예외 상황을 알린다는 의미고, 예외를 **잡아내는 것(catch)**은 예외를 처리한다는 것이다. 자바스크립트에서는 런타임 에러가 일어날 때마다 예외를 발생시킨다. 또한, 프로그램에서 명시적으로 예외를 발생시킬 때에도 마찬가지로 예외를 발생시킨다.

Error객체는 에러의 종류를 담고 있는 name 프로퍼티와 Error 클래스 생성자 함수에 넘기는 문자열 값을 담고 있는 message 프로퍼티를 가지고 있다.
```javascript
/* 유효하지 않은 전달인자가 있으면 예외를 발생 */
if (x < 0) throw new Error(“x must not be negetive”);
//유효할 때는 아래 코드를 실행
for(var f = 1; x > 1; f *= x, x--) /* 비어 있음 */;
return f;
}
```
예외가 발생하면 자바스크립트 인터프리터는 정상적인 프로그램 실행을 즉시 중단하고 예외처리기로 넘어간다. catch문이 그 역할을 하는데 예외가 발생한 코드 블록에 catch절이 없으면 상위 코드 블록에 있는 지 확인을 한다. 호출 스택에 따라서 예외가 전파되어 올라가고, 없을 경우 해당 예외는 에러로 취급되고 사용자에게 보고된다.

### 5.6.6 try/catch/finally
예외처리 기법, try 단순히 예외가 발생할지도 모르는 코드 블록을 정의, catch try블록 내부에서 예외가 발생할 경우 호출되는 문장 블록, catch다음에는 finally 블록이 올 수 있고 이 절은 try 블록과 관계없이 항상 실행되어야할 뒷정리용 코드가 들어간다.

catch절에는 지역 변수 e를 사용해 Error객체 또는 앞에서 던진 다른 값을 참조할 수 있다.

finally 절은 catch만큼 자주 쓰이지는 않지만 유용할 경우가 있다. try가 일부라도 실행되면 finally 절은 무조건 실행된다. return, continue, break 문 등을 만나 try 블록의 제어를 벗어날 경우, 새 지점으로 이동 전에 finally 블록이 실행된다.

## 5.7 기타
with, debugger, use strict에대해서 알아본다

### 5.7.1 with
with 문은 유효범위 체인을 임시로 확장할 때 쓰인다. 유효범위 체인의 첫 번째에 ‘객체’를 추가한 후 문장을 실행한 다음 객체를 추가하기 전 상태로 되돌려 놓는다.

with 문을 사용하는 코드는 최적화하기 힘들고 현저히 느리기 때문에 잘 사용하지 않는다. 주로 깊이 중첩된 객체 계층 구조를 좀 더 쉽게 다루기 위해 사용된다.
```javascript
document.forms[0].address.value
```
엘리먼트에 접근하기 위해 위의 코드와 같이 쓴다면 with문을 이용하면 아래와 같이 사용할 수 있다.
```javascript
with(document.forms[0]) {
	name.value = “”;
	address.value = “”;
	email.value = “”;
}
```
이와 같은 방식으로 붎ㄹ요한 타이핑을 줄 일 수 있다. with에 의해 추가된 임시 객체는 유효범위 체인의 일부가 되고 자바스크립트가 식별자를 판별할 때 사용된다.

같은 코드를 with 없이 사용할 수 있다.
```javascript
var f = document.forms[0];
f.name.value = “”;
f.address.value = “”;
f.email.value = “”;
```
유효범위 체인은 식별자를 생성할 때는 사용할 수 없고, 찾을 때 사용한다.

```javascript
with(o) x = 1;
```
만약 객체 o에 프로퍼티 x가 존재한다면 그 값을 1로 변경할 수 있지만 프로퍼티가 존재하지 않는다면 아무런 일도 일어나지 않는다.

### 5.7.2 debugger
debugger문은 평소에는 아무것도 하지 않는다. 하지만, 디버거 프로그램을 사용할 수 있고 디버거가 실행 중일 때, 자바스크립트 구현체는 해당 위치에서 정의된 코드 디버깅을 수행한다. 자바 스크립트 코드의 실행을 자시 멈추고 디버거 프로그램을 사용해 변수의 값을 출력, 호출 스택 등을 살필 수 있다는 뜻이다.
```javascript
/* 함수 f()가 인자 없이 호출되어 예외가 발생하고, 어느 시점에서 함수 호출이 발생하는 지 찾기 힘들 때*/
fuction f(o) {
	if (o === undefined) debugger;
	...
}
```

### 5.7.3 “use strict”
ES5에서 처음 소개된 지시어이다, 지시어는 문장이 아니지만 ‘use strict’는 문장에 가깝다.

해당 부분은 엄격모드에 관련된 것이며 나중에 다시 공부하기!