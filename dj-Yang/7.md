# 7장 배열
배열은 정렬된 값의 집합이다. 자바스크립트의 배열은 타입이 고정되어있지 않다. 같은 배열에 있는 원소 값의 타입은 서로 다를 수 있다. 배열의 원소로 객체가 될 수도 있고, 또 다른 배열이 될 수도 있다. 자바스크립트의 배열은 동적이다. 크기가 필요에 따라 커질 수도 있고, 작아질 수도 있다. 배열을 생성하거나, 크기가 변경되어 다시 할당을 할 때도 배열 크기를 선언할 필요가 없다. 자바스크립트 배열은 밀집도가 높지 않다(sparse). 각 원소의 인덱스가 연속적이지 않아도 되고, 원소들 사이에 빈자리가 있어도 된다. 자바스크립트 배열에는 length 프로퍼티가 존재한다. 빈자리가 전혀 없는 배열의 경우 length 프로퍼티의 값은 배열의 크기와 같지만, 희소배열(sparse array)의 경우는 실제 원소의 크기보다 크다.

자바스크립트 배열은 자바스크립트 객체의 특별한 형태이고, 배열의 인덱스는 프로퍼티 이름이 정수로 되어있는 것으로 보면 된다. 배열은 Array.prototype의 프로퍼티들을 상속받는다. 여기에는 여러 가지 배열을 다룰 수 있는 메서드들이 정의되어 있다. 대부분의 메서드는 제네릭(generic) 형태이고, 그렇기 때문에 유사 배열(array-like object)에서도 동일하게 동작한다.

## 7.1 배열 만들기
배열을 만드는 가장 쉬운 방법은 배열 리터럴을 사용하는 방법이다.
```javascript
var empty = [];
```

배열 리터럴의 값으로는 상수뿐 아니라 임의의 표현식도 가능하다.
```javascript
var base = 1024;
var table = [base, base+1, base+2, base+3];
```
객체 리터럴 또는 또 다른 배열 리터럴 또한 포함할 수 있다.

배열 리터럴에서 빠진 부분이 존재할 경우, 해당 원소 값은 undefined 값이 된다.

배열 리터럴의 문법은 마지막 원소 다음에 쉼표를 추가할 수 있다고 명시하고 있다.
```javascript
var undefs = [,,];
```
위의 코드는 undefined 값을 가진 **두 개**의 원소를 가지고 있다.

배열을 만드는 또 다른 방법은 Array() 생성자를 이용하는 방법이고 이 생성자는 3가지 방법으로 사용할 수 있다.
1. 인자 없이 호출하는 방법
```javascript
var a = new Array();			// var a = []; 와 동일
```

2. 배열의 길이를 의미하는 숫자 값을 인자로 주어 호출하는 방법
```javascript
var a = new Array(10);
```
생성자의 인자로 전달받은 숫자 값만큼 원소를 갖는 배열을 생성한다. 배열에는 어떠한 값도 저장되지 않고 인덱스 프로퍼티 역시 존재하지 않는다.

3. 두 개 이상의 원소, 또는 숫자가 아닌 원소 값 하나를 명시적으로 지정
```javascript
var a = new Array(1, 2, 3, 4, 5, “testing, testin”);
```

## 7.2 배열의 원소 읽고 쓰기
배열의 각 원소에 접근할 때에는 [] 연산자를 사용한다. [] 안에는 음이 아닌 정수 값으로 평가되는 임의의 표현식이 위치할 수 있다.

배열은 객체의 특별한 종륭기 때문에 [] 구문은 객체 프로퍼티 접근 때 쓰는 []와 똑같이 동작한다. 자바스크립트는 사용자가 명시한 숫자 배열 인덱스를 문자열 형태로 바꿔서 프로퍼티 이름으로 사용한다. (ex, 인덱스가 1이라면 문자열 ‘1’로 프로퍼티에 접근)

배열이 일반 객체와 다른 점은 속성 이름으로 2^32보다 작은 양수를 사용할 때, 자동으로 length 프로퍼티의 값을 바꾼다는 것이다.

배열의 인덱스(array index)와 객체 프로퍼티 이름(object property name)을 올바르게 구별할 줄 알면 좋다. 모든 인덱스 값은 프로퍼티 이름이지만, 프로퍼티 이름은 0과 2^32-1 사이의 정수여야 인덱스가 될 수 있다. 배열은 객체이므로 어떤 이름의 프로퍼티라도 자유롭게 만들 수 있지만 프로퍼티 가운데 인덱스인 것들을 사용하면 length 프로퍼티의 값이 자동으로 갱신된다.
```javascript
var a = [];			// 빈 배열
a[0] = 1;			// [1]
a.length;			// 1
a[“test”] = 2;			// [1, test:2]
a.length;			// 1
```

배열 첨자로 음수나, 정수 아닌 수들을 사용할 수 있기는 하지만 이 경우 숫자가 문자열로 변환되고 그 문자열이 배열 객체의 프로퍼티 이름으로 사용된다. 또한, 배열 첨자로 양의 정수가 담긴 문자열을 사용하면, 일반적인 프로퍼티가 아닌 배열 인덱스로 쓰인다. 소수점 아래가 없는 부동 소수점을 쓸 때도 같다.

배열 또한 특별한 종류의 객체이기 때문에 자바스크립트 배열에서는 “out of bounds” 에러가 발생하지 않는다. 존재하지 않은 프로퍼티 이름을 질의해도 undefined 값만 반환한다. 또한 객체의 프로토타입으로부터 원소들을 상속받을 수 있다. ES5에서는 getter/setter메서드를 통해 정의된 원소도 가능하기는 하다. 하지만 최적화된 코드를 사용하지 않은 코드를 사용하기 때문에 일반 객체 프로퍼티 접근과 속도면에서 비슷하다.

## 7.3 희소배열
희소 배열(sparse array)는 원소의 위치가 연속적이지 않은 배열을 뜻한다. 보통 배열에서 length 프로퍼티는 배열에 속한 원소의 개수를 의미하지만 희소 배열에서의 값은 원소의 개수보다 항상 크다.

Array() 생성자를 통해 만들거나, 단순히 배열의 크기보다 큰 인덱스에 값을 할당하여 만들 수 있다.
```javascript
a = new Array(5);		// 원소가 없지만 a.length는 5를 반환
a = [?];				// length = 0
a[1000] = 0;			// 하나의 원소를 할당하지만 length = 1001
```
delete로 앞 자리의 인덱스에 해당하는 값을 지웠을 때도 희소 배열로 동작한다.

희소 배열은 보통 배열보다 일반적으로 느리고, 메모리 사용을 많이 하며, 원소를 찾는데 걸리는 시간이 일반 객체의 속성 값을 찾는 시간만큼 오래 걸린다.

배열 리터럴로는 희소 배열을 만들 수 없다. 배열 리터럴로 만들 경우 값을 넣지 않아도 해당 위치에 undefined값이 존재하는 것처럼 동작하기 때문이다. 이는 in 연산자를 사용하거나 for/in 루프를 사용할 때 명확히 드러난다.

## 7.4 배열의 길이
모든 배열에는 length 프로퍼티가 있다. 이는 객체와 구분되는 배열만의 중요한 특징이다.

희소 배열의 경우 length 프로퍼티는 항상 원소의 개수보다 큰데, 이는 배열의 length가 배열에 속한 모든 원소의 인덱스보다 항상 크다는 의미이다. 즉 원소의 인덱스는 배열의 length보다 절대로 크거나 같을 수 없다. 이 법칙을 지키기 위해 배열은 두 가지 독특한 작동을 한다.
1. 만약 배열에 배열의 현재 크기보다 같거나 큰 인덱스 i를 갖는 원소를 삽입하는 경우, 배열의 length 값은 자동으로 i+1로 설정된다.
2. 만약 음이 아니며 기존 length 값보다 작은 정수 n을 length 값으로 할당할 경우, n번째 인덱스보다 크거나 같은 위치에 있는 원소는 배열에서 삭제한다.
```javascript
a = [1, 2, 3, 4, 5];
a.length = 3;			// a는 [1, 2, 3]
a.length = 0;			// a는 []
a.length = 5;			// a는 new Array(5)와 같다, 원소가 없다.
```

ES5에서는 배열의 length 프로퍼티 값을 object.defineProperty() 메서드를 사용해 읽기 전용으로 만들 수 있다. 마찬가지로 배열의 어떤 원소를 설정 불가능하게 만든다면 원소를 지울 수 없고, 배열의 length 프로퍼티 값 역시 해당 원소의 인덱스보다 작은 값으로 설정할 수 없다.

## 7.5 배열에 원소를 추가하거나 삭제하기
배열에 원소를 추가하는 방법은 배열에 새 인덱스에 값을 할당하거나 push() 메서드를 사용하는 방법도 있다. push() 메서드로 추가하는 것은 a[a.length]에 값을 할당하는 것과 같다. unshift() 메서드를 사용하면 배열의 앞쪽에 원소를 추가할 수 있다.

객체에서 프로퍼티를 지울 때와 마찬가지로 delete 연산자로 배열의 원소도 지울 수 있다.

>배열은 특이한 형태의 객체이다!

하지만, 배열에 delete로 원소를 지운다고 해도 length의 크기는 변하지 않는다. => 희소 배열이 되는 것이다.

## 7.6 배열 순회하기
가장 일반적인 순회 방법은 for 루프를 사용하는 것이다.

중첩 루프 또는 성능에 민감한 컨텍스트에서 배열을 순회할 때는 매번 배열의 length를 가져오기보다, 한 번만 가져와서 사용하도록 최적화하는 경우도 있다.
```javascript
for(var i = 0, i < keys.length; i++);
// 위의 코드는 지속적으로 keys에 접근해야한다.
for(var i = 0, len = keys.length; i < len; i++);
//한번만 접근해 값을 가져온다
```

순환을 하기 전에 배열의 원소가 제대로 있는 지 확인하고 원하지 않은 값이 있을 경우를 배제해주는 코드를 마련해야한다.

앞장에서 확인했듯이, for/in 루프는 상속받은 프로퍼티 이름까지 넘겨준다. 따라서 원하지 않는 프로퍼티를 제외하는 테스트를 포함하지 않았다면 for/in 루프를 사용하지 말아야한다.

ES 명세는 for/in 루프가 객체의 프로퍼티들을 어떤 순서로 순회해야하는 지 정해놓고 있지 않다. 배열이 객체 프로퍼티와 배열의 원소 둘 다 가지고 있다면, 프로퍼티 이름은 그 크기 순서가 아니라 생성된 순서로 반환될 수도 있다. 따라서 순서가 중요하다면 for/in 루프보다는 for 루프를 사용해야한다.

ES5에서는 배열을 순회하는 다양한 메서드가 추가되었고 forEach()메서드가 대표적이다. 배열을 다룰 때 forEach9) 같은 순회 메서드는 간단하고 강력한 함수형 프로그래밍이 가능하게 해준다.

## 7.7 다차원 배열
자바스크립트에서는 다차원 배열을 지원하지는 않는다. 하지만 다차원 배열을 흉내낼 수 있다. 단순하게 [] 연산자를 두 번 사용하면 된다.

##7.8 배열 메서드
ES3의 Array.prototype은 배열을 다루는 데 필요한 여러 종류의 함수들을 정의하고 있다. 정의된 함수들은 모든 배열에서 메서드로 사용할 수 있다.

### 7.8.1 join()
Array.join() 메서드는 배열의 모든 원소를 문자열로 변환하고, 변환한 문자들을 이어 붙인 결과를 반환. 반환된 문자열에서는 구분자 문자열로 구별된다. String.split() 메서드와는 반대로 작동한다.

### 7.8.2 reverse()
Array.reverse() 메서드는 배열의 원소 순서를 반대로 뒤집어 반환한다. 이 작업은 배열 내에서 시행된다(새로운 배열이 만들어져 반환되는 것이 아니다). 이를 위해 reverse()메서드와 join()메서드가 사용된다.

### 7.8.3 sort()
Array.sort() 메서드는 배열 안의 원소들을 정렬하여 반환한다.별도의 전달인자가 없으면 알파벳 순으로 정렬된다. 필요한 경우 비교를 위해 원소들을 문자열로 변환한다. undefined 원소는 배열의 끝부분으로 정렬된다. 다른 순서로 배열을 정렬하려면 전달인자를 통해 비교 함수를 직접 명시해주어야 한다. 두 개의 전달인자를 받아서 첫 번째 인자가 두 번째 인자보다 먼저 나와야한다면 비교함수는 0보다 작은 값을 반대로 되야한다면 0보다 큰 값을 동등하다면 0을 반환하는 함수를 정의해주면 된다.

### 7.8.4 concat()
Array.concat() 메서드는 기존 배열의 모든 원소에 concat() 메서드의 전달인자들을 추가한 새로운 배열을 반환한다. 전달인자에 중첩배열이 포함되어 있다면 중첩된 배열의 원소까지는 꺼내지 않는다.
```javascript
var a = [1, 2, 3];
a.concat([4,5],[6,7]);			// [1,2,3,4,5,6,7]
a.concat(4, [5, [6,7]]);			// [1,2,3,4,5,[6,7]]
```

### 7.8.5 slice()
Array.slice()메서드는 부분 배열(subarray)을 반환한다. 두 개의 전달인자를 받는데 반환될 부분의 처음과 끝을 명시한다.

### 7.8.6 splice()
Array.splice() 메서드는 배열의 원소를 삽입하거나 원소를 제거할 때 범용적으로 사용할 수 있는 메서드다. 이 메서드는 호출 대상 배열을 바로 수정한다. 

첫 번째 전달인자는 배열상에서 삽입 혹은 삭제 작업을 시작할 위치를 지정.

두 번째 전달인자는 배열에서 삭제할 원소의 개수를 지정, 두 번재 전달인자를 지정하지 않으면 첫 번재 전달인자로 지정한 배열의 시작 위치에서 마지막 원소까지 전부 삭제한다. 삭제한 후 삭제한 배열을 반환한다. 삭제한 원소가 없다면 빈 배열을 반환한다.

세 번째 전달인자는 배열에 새롭게 삽입할 원소들을 지정하는데 사용된다. 삽입 작업은 첫 번째 전달인자로 지정된 시작 위치부터 수행된다.

### 7.8.7 push()와 pop()
push()와 pop() 메서드를 사용하면 배열을 마치 스택처럼 조작 가능하다. 해당 메서드들은 배열을 새로 만들어내는 것이 아니라 배열 그 자체를 변화시킨다.

push, pop 메서드를 이용하면 FILO 스택을 구현할 수 있다.

### 7.8.8 unshift()와 shift()
unshift()와 shift() 메서드는 push(), pop() 메서드와 유사하게 동작하지만 배열의 맨 앞에서 원소를 추가하고 제거한다는 점에서 다르다.

단, unshift()의 전달인자로 여러 개의 원소들을 한꺼번에 배열에 추가하면 예상치 못한 결과를 얻을 수 있다. unshift()는 전달인자의 원소들을 하나씩 배열에 추가하는 대신, 모든 전달인자를 한꺼번에 배열에 추가한다. 새로운 배열의 원소순서는 메서드의 전달인자의 원소 순서와 동일하다.

### 7.8.9 toString()과 toLocaleString()
자바스크립트 객체와 마찬가지로 배열에는 toString() 메서드가 있다. 배열의 모든 원소를 문자열로 변환하고 문자열들을 쉼표로 분리한 목록을 반환한다. 변환된 문자열은 대괄호 문자나 배열 값의 종류를 분류하는 구분자를 포함하지 않는다.

toLocaleString()은 toString()의 지역화 버전이다. 이 메서드는 우선 배열의 각 원소들을 그 원소의 toLocaleString() 메서드를 사용해 변환하고, 변환된 문자열들을 지역화된 구분자 문자열로 연결하여 반환한다.

## 7.9 ES5 배열 메서드
ES5는 배열을 순회, 매핑, 필터링, 테스팅, 감소, 검색하기를 위한 아홉 가지 메서드를 정의한다.

ES5 메서드는 먼저 첫 번째 전달인자로 함수를 받는데, 이는 배열의 각 원소마다 한 번씩 실행하거나 일부 원소들에 한해 실행된다. 희소 배열일 경우 함수를 호출하지 않는다. 대부분의 함수는 세 개의 전달인자를 가지고 호출되는데, 이는 배열 원소의 값과 인덱스, 배열 그 자체를 갖는다. 첫 번째 전달인자만을 사용하고 나머지 전달인자를 무시할 경우도 종종 있다.

두 번째 인자는 생략 가능하다. 만약 두 번째 전달인자를 지정하면 첫 번재 전달인자인 함수는 마치 두 번재 인자의 메서드인 것처럼 호출된다. 두 번째 인자는 첫 번째 전달인자인 함수 안에서 *this 키워드의 값*으로 사용된다.

ES5 배열 메서드는 호출 대상 배열을 수정하지 않는다. 물론 메서드의 전달인자로 쓰인 함수 안에서는 배열을 수정할 수 있다.

### 7.9.1 forEach()
forEach() 메서드는 배열을 순회하는 메서드로, 첫 번째 인자로 넘긴 함수를 각각의 원소를 대상으로 호출한다. 첫 인자로는 ES5 배열 공통 인자를 따른다. forEach() 메서드는 배열의 모든 언소가 순회되기 전에는 종료되지 않는다. 루프에서 사용하는 break문을 사용할 수 없다. 중간에 중단을 시키면은 예외를 발생시켜야하므로 forEach()는 try 블록 안에서 호출해야한다.

### 7.9.2 map()
map() 메서드는 배열의 각 원소를 메서드의 첫 번째 전달인자로 지정한 함수에 저장하고, 해당 함수의 반환 값을 배열에 담아 반환한다.

map()은 forEach()에 전달한 함수와 동일한 형태로 호출되지만 다른 점은 인자로 전달된 함수는 반드시 값을 반환해야 한다. 또한, 기존 배열을 수정하는 것이 아니라 새 배열을 반환하고 배열이 희소배열이면 반환된 배열도 희소배열이 된다. 기존배열과 반환된 배열이 길이가 같고, 빈 원소 개수 역시 같다.

### 7.9.3 filter()
filter() 메서드는 배열의 일부분을 반환한다. 이 메서드에 전달하는 함수는 조건자 함수여야한다. 반환 값이 true or false인 함수. 조건 함수는 map(), forEach()와 동일한 형태로 반환되고 반환 값이 true이거나 true로 변환되는 값이면 조건자 함수에 전달된 값은 filter가 반환할 배열에 추가된다.

filter() 메서드는 희소 배열같은 경우에 있는 빈 원소를 건너 뛰기 떄문에 반환 배열에는 빈 원소가 없다, 희소 배열의 빈 원소를 제거하고 싶다면 filter()로 이용가능하다. 응용하면 null, underfined를 제거한 배열 또한 만들 수 있다.

### 7.9.4 every()와 some()
every()와 some()) 메서드는 배열 조건자 함수(predicate)다. 두 메서드는 인자로 주어진 조건자 함수를 각 원소에 적용한 후 최종적으로 true or false를 반환한다.

every()는 말 그대로 모든 조건이 조건자 함수에 일치해야 true를 반환하고 그 외의 경우에는 false를 반환한다.

some() 메서드는 일부만 조건자 함수에서 true라면 true를 반환하고 일치하는 부분이 아예 존재하지 않는다면 false를 반환한다.

두 메서드는 반환 값이 결정되면 배열의 원소 순회를 중단한다. 빈 배열일 경우 every() 메서드는 항상 true를 some() 메서드는 항상 false를 반환한다.

### 7.9.5 reduce()와 reduceRight()
reduce()와 reduceRight() 메서드는 인자로 주어진 함수를 사용하여 배열의 원소들을 하나의 값으로 결합한다. inject와 fold 연산을 수행한다.

>고차함수(fold) : 함수의 매개변수나 반환 값으로 또 다른 함수를 사용할 수 있는 함수

reduce() 메서드는 두 개의 인자를 갖는다. 첫 번째 인자는 배열 원소의 감소 작업을 하는 함수다. 감소 함수는 배열 원소 중 두 값을 하나로 결합하면서 크기를 줄이고 남은 값을 반환한다. 두 번째 인자는 생략가능하며 감소 함수에 전달할 시작 값이다.
```javascript
var a = [1, 2, 3, 4, 5];
var product = a.reduce(function(x,y) { return x*y }, 1);		//120
var product = a.reduce(function(x,y) { return x*y }, 3);		//360
// 360 결과값은 `3`*1*2*3*4*5 의 결과물 표시한 3은 위의 두번째 인자
```
초기값 없이 reduec() 메서드를 호출할 경우에는 배열의 첫 번째 원소를 초기 값으로 사용한다.

reduceRight() 메서드는 reduce()와 동작은 같지만, 배열의 끝부터 시작해 반대 방향으로 처리한다.

두 메서드는 감소 함수 호출 시 사용할 this 값을 선택인자로 지정할 수 없다. 선택 초기 값 인자만 지정할 수 있다.(감소 함수를 특정 object의 메서드로 호출하고 싶을 때는 Fuction.bind() 메서드 이용.

reduce()와 reduceRight() 메서드는 단순히 수치 연산만을 위해 사용되는 것은 아니다. 두 객체를 사용해 새로운 객체를 반환하는 union()이 감소함수와 유사하다. 따라서 reduce()를 사용하면 여러 객체를 합칠 수 있도록 union()을 일반화 가능하다.(어렵)

### 7.9.6 indexOf()와 lastIndexOf()
indexOf()와 lastIndexOf() 메서드는 배열의 원소 중에서 특정한 값을 찾는다. 값이 존재하면 해당 값의 인덱스를 반환하고, 존재하지 않을 경우에는 –1을 반환한다. 두 개의 메서드는 각각 배열의 처음부터, 끝에서부터 검색한다는 것에 차이 점이 있다.

두 개의 메서드는 인자로 함수를 받지 않고 배열에서 찾고자 하는 값을 첫 번째 인자로 두 번째 인자는 생략이 가능한 인자인데 검색을 시작할 배열의 인덱스를 지정할 수 있다.

## 7.10 배열 타입
배열은 특별한 형태의 객체이다. 임의의 객체가 배열인지 여부를 판별하는 작업은 매우 유용하다.

ES5 이전에는 임의의 객체가 배열인지를 판단하기가 어려웠다 typeof 연산자가 배열뿐 아니라 함수를 제외한 모든 객체에서 object를 반환했기 때문이다. 단순한 형태라면 instanceof 연산자를 사용할 수 있다.
```javascript
[] instanceof Array		// => true
({}) instanceof Array		// => false
```
위의 방식은 웹브라우저에서 문제가 생길 수 있는 하나 이상의 창 또는 프레임이 열려있을 때 종종 발생한다. 각 창 또는 프레임은 고유한 자바스크립트 실행 환경과 전역 객체를 가지고 있다. 또한, 각각의 전역 객체는 별도의 생성자 함수들을 가지고 있다. 따라서 하나의 프레임에 속한 객체는 다른 프레임에 속한 생성자의 인스턴스가 될 수 없다. 프레임 간의 혼동이 자주 발생하지는 않지만, instanceof 연산자로는 배열인지 확실하게 검증할 수 없다.

## 7.11 유사 배열 객체
자바스크립트 배열에는 다른 객체 없는 몇 가지 특징이 있다.
- length 프로퍼티는 배열에 새 원소가 추가될 때마다 자동으로 갱신된다.
- length 값을 임의로 설정함으로써 배열의 크기를 줄일 숭 lTek.
- 배열은 Array.prototype에 정의된 유용한 메서드들을 상속한다.
- 배열의 class 속성 값은 “Array”로 설정된다.

실무에서는 실제 배열뿐만 아니라 유사 배열 객체에서 배열 알고리즘이 잘 작동한다.

클라이언트 측 자바스크립트에서는 상당수의 DOM 메서드가 배열과 유사한 객체를 반환한다.

ES5 에서는 문자열을 배열처럼 사용할 수 있지만 문자열은 배열로 다루기보다 문자열 그 자체로 다루는 편이 최선이다.

유사 배열 메서드는 Array.prototype을 상속받지 않기 때문에, 배열 메서드를 해당 객체의 메서드로 호출할 수 없다. 대신 Function.call 메서드를 통해서 간접적으로 호출할 수 있다.

>call 메서드 : 첫번째 인자로 객체를 주는데 call()을 호출하는 함수가 인자로 주어진 객체에 딸려 있는 객체처럼 동작

정적 함수 형태의 배열 메서드는 유사 배열을 다룰 때 유용하지만 표준이 아니라서 모든 브라우저가 지원한다는 보장이 없다. 다라서 그에 맞는 코드를 사용하기 전에 추가 해주어야한다.

## 7.12 문자열을 배열처럼 사용하기
ES5에서는 문자열은 읽기 전용 배열처럼 동작한다. []를 이용해 접근할 수 있다는 뜻이다.

push()와 sort(), reverse(), splice()와 같은 배열 메서드는 배열을 직접 수정하므로 문자열에서는 동작하지 않는다.
