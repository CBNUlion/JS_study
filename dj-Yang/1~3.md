# 1장 자바스크립트 소개

## 1.1 자바스크립트 코어
스크립트 언어

## 1.2 클라이언트 측 자바스크립트
유용함

# 2장 어휘 구조

## 2.1 문자 집합
### 2.1.1. 대소문자 구분
자바스크립트는 대소문자를 구분해야하는 언어이다.
(HTML은 대소문자를 구분하지 않는다.)

자바스크립트에서는 태그나 속성 이름을 모두 소문자로 입력해야한다.

### 2.1.2 공백, 줄바꿈, 제어문자
### 2.1.3 유니코드 이스케이프 시퀀스
### 2.1.4 유니코드 정규화

## 2.2 주석
// : 단일 줄 주석
/**/ : 범위 주석

## 2.3 리터럴
>리터럴 : 프로그램에 직접 나타나는 데이터 값 -> 3장에서 자세히 배움

## 2.4 식별자와 예약어
>식별자 : 변수나 함수에 이름을 붙이거나 코드 내 반복문에서 쓸 레일블을 붙이는데 사용

자바스크립트 만의 규칙에 따름 보통

>예약어 : 언어 내부적으로 사용할 용도로 만들어진 단어, 식별자로 활용 불가능

### 2.4.1 예약어
break case, delete 등

ES5 에는 class const enum, import 등이 추가되었다.

또한, 보통 자바스크립트에서 식별자로 사용할 수 있지만 엄격 모드에서는 사용할 수 없는 단어들도 있다. -> yield interface protected static
엄격모드에서는 ***arguments eval*** 등과 같은 식별자들을 변수나 매개변수 이름으로 사용 또한 못하게 한다.

ES5와 달리 ES3에서는 자바의 예약어를 그대로 사용했기 때문에 유의해서 식별자를 사용해야한다.

함수 또한 마찬가지로 정해진 것들이 있다.

## 2.5 선택적인 세미클론 사용
자바스크립트 또한 문장을 구분하기 위해 세미콜론을 사용(5장),
but, 여러 문장이 서로 다른 줄에 나타나는 경우나 프로그램의 끝이나 다음 토큰이 ‘}’라면 세미콜론을 생략 가능.

->하지만 명시적으로 세미콜론을 사용하는 것이 좋다.

```javascript
a = 3;  //세미콜론 생략 가능
b = 4;

a =3; b = 4l  //세미콜론 생략 부가능
```
자바스크립트가 항상 세미콜론을 해석하는 것은 아니고 세미콜론이 없을 때 코드를 해석할 수 없는 경우에만 해석한다.

몇 가지 예외를 제외하고는 JS는 다음 줄에 나오는 공백 아닌 첫 문자를 현재 문장고 이어서 해석할 수 없을 경우에만 세미콜론으로 취급

```javascript
var a
a
=
3
console.log(a)
/*위의 코드는 아래 코드와 같다*/
var a; a = 3; console.log(a); 
```

일부 프로그래머들은 문자의 시작 부분에 방어적인 세미콜론을 넣어주기도 한다.

```javascript
var x = 0
;[x, x+1, x+2].forEach(console.log)
```
다음 줄을 첫 줄의 문장과 이어서 처리할 수 없는 경우는 두 가지 예외가 있다.
1. return, breake, continue 문 바로 다음에 올 경우
```javascritpt
return
true;

//우리가 원했던 코드
return true;

//실제 실행되는 코드
return; true;
```

2. ++나 —연산자가 포하된 경우
```javascript
x
++
y

//예상코드
x++; y

//실제코드
x; ++y
```

# 3장 타입, 값, 변수
자바 스크립트의 타입
1. 원시 타입(primitive type) : 숫자, 문자열, 불리언

2. 객체 타입(object type) : 이름과 값을 갖는 프로퍼티의 집합

3. 독립적인 타입 : null, undefined

자바스크립트 특징
-자바스크립트 인터프리터는 메모리 관리를 위해 자동으로 가비지 컬렉션(garbage collectoin)을 수행한다.
- 자바스크립트는 객체 지향 언어이다.
```javascript
a.sort(); //sort(a)의 객체 지향 버전
```

## 3.1 숫자
자바스크립트는 정수 값과 실수 값을 구분하지 않는다.
프로그램 안ㅇ서 있는 그대로 등장하는 숫자를 숫자 리터럴(numeric literal)이라고 한다.

### 3.1.1 정수 리터럴
10진수 정수는 숫자를 일렬로 나열한 것이다.
16진수는 앞에 ‘0x or 0X’를 붙인다.
8진수는 ES 표준에서 지원하지 않지만 사용할 수는 있다. 하지만 10진수의 정수와 헷갈릴 수 있기 떄문에 사용하지 않는다.

### 3.1.2 부동소수점 리터럴
- 소수점을 가질 수 있는 리터럴이다.
- 지수 표기법으로도 표현이 가능하다.
>표현법 : [“digits”][.“digits”][(E|e)[(+|-)]“digits”]

### 3.1.3 산술 연산
기본적인 사칙 연산(+, -, *, /)을 포함하여 복잡한 수치 연산을 위해 Math 객체를 지원한다.
>Math : 수치 연산에 쓰이는 다양한 함수와 상수들이 **프로퍼티** 형태로 정의되어 있다.

자바스크립트의 산술 연산은 오버플로. 언더플로와 0으로 나누는 에러를 발생 시키지 않는다.
- 표현할 수 있는 값보다 클 때 -> Infinity
- 표현할 수 있는 값보다 작을 때 -> -Infinity, 
- 0에 가까운 가장 작은 값이 표현할 수 있는 값보다 작을 때 -> 0
- 0으로 나눌 때 -> Infinity
- 0을 0으로 나눌 때 -> NaN 반환(모든 이해할 수 없는 연산일 때)

※ ES3에서는 Infinity, NaN를 식별자처럼 사용했지만 ES5에서는 읽기 전용 값으로 변경되었다. (Number 객체에는 Infinity와 NaN을 따로 상수로 정의해 놓았고 읽기전용이다)
```javascript
Infinity   //읽고 쓰기 가능한 변수 ES3에서만
Number.POSTIVE_INFINITY // 읽기 전용
```

NaN은 자신 뿐만 아니라 다른 값과 같은 지 비교할 수 없다. 값 비교가 필요할 때는 NaN이 나타내는 변수를 통해 비교를 진행해야 한다.

음의 0 또한 나눗셈을 진행할 경우 ‘1/0’과 ‘1/-0’ 이랑은 다른 값으로 나온다.

### 3.1.4 이진 부동소수점과 반올림 오류
자바스크립트에서는 한정된 숫자만 부동소수점 형태로 표현 가능하다.
자바스크립트는 실수 연산을 할 때 이진 표현법 방식을 이용한 근사 값으로 표현한다.
따라서 1/10을 0.1로 표현하는 간단한 값도 정확하게 표현하지 못한다.
```javascript
var x = .3 - .2;
var y = .2 - .1;
x==y  //false
x==.1 //false
y==.1 //true
//근사치 사이의 차이가 다르기 때문에 위와 같은 오류가 발생한다.
//x, y 모두 .1 에 가깝지만 조금씩은 다르다.
```

### 3.1.5 날짜와 시간
코어 자바스크립트는 날짜와 시간을 표현하는 개체를 생성하는 Date() 생성자를 제공한다.

## 3.2 텍스트
자바스크립트는 16비트 문자열을 사용한다. 따라서 길이 1은 16비트를 뜻하고 한 글자를 뜻한다. 16비트로 표현하지 못하는 값은 16비트를 2개 사용하여 한 글자를 표현한다.

### 3.2.1 문자열 리터럴
작은 따옴표 or 큰 따옴표로 둘러싸면 사용가능하다. ES3에서 문자열 리터럴은 한 줄로 작성해야 했지만 ES5에서는 역슬래시(\)를 사용하면 한 줄을 여러 줄로 사용할 수 있다.

>문자열 리터럴로 작은 따옴표를 사용할 때는 영어의 단축형 표현과 소수형 표현 단어를 주의 해야한다

### 3.2.2 문자열 리터널 내의 이스케이프 문자열
역슬래시(‘\’)를 이용하여 특수한 목적을 가진다.

### 3.2.3 문자열 다루기
자바스크립트는 +를 통해 여러 문자열을 이어붙이는 것이 가능하다.

자바스크립트에는 문자열을 다루는 다양한 메서드가 있다.(자세히 알고 싶다면 레퍼런스 참조)
대표적으로 length 프로퍼티가 있는데, 사용하면 문자열의 길이를 반환한다.

>사용법 : (문자열 변수).length

자바스크립트에서 문자열은 **변경되지 않는다.** replace()와 toUpperCase()같은 메서드는 기존 문자열을 변경하지 않고 **새 문자열**을 반환한다.

ES5에서 문자열은 읽기 전용 배열처럼 취급 가능하다 즉 인덱싱과 유사한 방식으로 개별 문자로 접근이 가능하다.

### 3.2.4 패턴 매칭
자바스크립트는 문자 패턴을 나타내는 객체를 생성하기 위해 RegExp() 생성자를 제공한다. 이를 **정규 표현식**이라고 부르며, 자바스크립트는 정규 표현식을 위해 펄(Perl)의 구문을 따른다.

>펄(Perl) : 텍스트를 처리하는 기능이 최강점으로 가지고 있는 언어의 한 종류

RegExp는 원시 타입이 아닌 Date처럼 유용한 API를 가지고 있는 특별한 종류의 객체이다.
자세한 것은 10장에서 배운다.

## 3.3 불리언 값
자바스크립트에서 **false**에 해당하는 값
- undefined
- null
- 0
- -0
- NaN
- “” //빈 문자열

객체를 포함하는 다른 모든 값은 **true**로 변환되어 해석한다.

불리언 값의 세 가지 중요 연산자
1. && = AND연산
2. || = OR연산
3. ! = NOT연산

## 3.4 null과 undefined
null : 아무 값도 갖지 않는 키워드, type을 알아보면 object로 나온다. => 값이 없음을 나타내는 특별한 객체
undefined : null보다 deep한 아무 값도 갖지 않는 키워드. 초기화하지 않은 변수나 존재하지 않는 객체 프로퍼티나 배열의 원소 값에 접근하려고 할 때 반환. 특별한 고유의 값

동치 연산자(‘==’)를 사용하면 null과 undefined는 같은 값을 가진다고 나온다.
```javascript
null == undefined  //true
```
보통 시스템 수준에서 예기치 않은 상황에 발생한, 오류성 값 부재를 표현할 때는 undefined를 사용하고, 일반적인 프로그램에서는 null을 사용하는데, 만약 변수나 프로퍼티에 할당할 필요가 있거나 함수의 인자로 전달할 필요가 있다면 null을 사용하는 것이 적절하다.

## 3.5 전역 객체
전역 객체의 프로퍼티는 자바스크립트 프로그램 전영에서 사용할 수 있게 정의된 심벌이다.

자바스크립트는 인터프리터가 시자할 때(또는 웹 브라우저가 새로운 페이지를 로딩할 때), 새로운 전역 객체를 만들고 그 프로퍼티들을 초기화한다.
- undefined, Infinity, NaN 같은 전역 프로퍼티
- isNaN(), parseInt(), eval() 같은 전역 함수들
- Date(), RegExp(), String(), Object(), Array() 같은 생성자 함수
- Math와 JSON 같은 전역 객체

최상위 코드 or 함수의 일부가 아닌 코드에서는 this 키워드를 통해 전역 객체를 참조할 수 있다.
```javascript
var global = this;
```

클라이언트 측면에서 Window 객체는 브라우저를 포함해서 모든 자바스크립트를 위한 전역객체이다.
Window 객체는 자기 자신을 참조하는 window 프로퍼티를 가지고 있다.

우리가 전역 변수를 선언하면 자동적으로 전역 객체의 프로퍼티화 된다.

## 3.6 래퍼(wrapper) 객체
>객체 : 프로퍼티 또는 이름 있는 값들의 집합

문자열은 객체가 아님에도 프로퍼티를 가지고 있는 이유
```javascript
var s = “hello world”;  // 자동적으로 new String(s) 형식으로 임시 객체를 만든다.
var word = s.substring(s.indexOf(“ ”)+1, s.length);
```
숫자와 불리언 또한 위의 상황과 같다.

위의 예제에서 s의 프로퍼티에 값을 할당하게 된다면 해당 코드가 실행되었을 때 임시 객체를 s라는 값을 가지는 임시 객체를 생성했다가 삭제한다. 따라서 다음 코드에 s.len을 사용하려고 해도 undefined 라는 값이 반환된다.
```javascript
var s = “test”;
s.len = 4;  //“test”라는 문자열을 가진 String 임시 객체 생성 후 len 프로퍼티에 4값 부여 후 임시 객체 생성
var t = s.len;  //“test”라는 문자열을 가진 String 임시 객체 생성 후 len 프로퍼티 확인
```

이러한 임시 객체를 래퍼(wrapper) 객체로 알려져 있다.

명시적으로 임시 객체를 생성할 수 있지만 잘 사용하지는 않는다.

## 3.7 변경 불가능한 원시 타입 값과 변경 가능 객체 참조
원시 타입 값과 객체의 가장 큰 차이점 원시 타입의 값은 **수정**이 불가능하다.

문자열 메소드를 이용하면 새로운 문자열을 생성하여 반환하는 것이 기존의 문자열은 변경되지 않는다.
```javascript
var s = “hello”;  // 문자열 “hello”을 s에 저장
s.toUpperCase();  // 문자열 “HELLO”를 반환
s;  		  // 문자열 “hello“
```

원시 타입은 값으로 서로를 비교한다.(단, 문자열 같은 경우는 문자열의 길이가 같고 각 인덱스에 있는 문자들이 같다면 두 문자열을 같다고 판단한다)

객체는 원시 타입과 다르게 자신의 값을 변경할 수가 있다.(mutable)

객체는 **값으로 비교되지 않는다,** 같은 프로퍼티와 값을 가지고 있어도 두 객체는 같지 않다.

객체는 참조 타입으로 불리운다.(원시타입과 구별됨)
```javascript
var a = [];
var b = a;
```
위의 a, b 는 전부 배열 객체를 참조한다. a[0]에 값을 부여하면 b[0]도 같은 값이 부여된다.
위와 같은 방법을 단순히 참조를 할당한다고 한다.
즉, 같은 개체를 동시에 바라보고 있는데 만약, 별개의 함수를 바라보게 하고 싶다면 명시적으로 객체의 프로퍼티 또는 배열의 원소를 복사해야한다.

## 3.8 타입 변환
자바스크립트는 타입에 대해 매우 유연한 언어이다.
불리언을 나타내기 위해 다른 타입을 이용할 수 있다.

같은 의미로 자바스크립트가 해당 자리에 문자열이 오기를 원한다면 어떤 타입을 사용해도 문자열로 저장이 된다.
```javascript
30 + “ object”	// “10 object” 10이 문자열로 변한다
“4” * “7”	// 28

//만약, 의미 있는 값으로 변환이 어렵다면 NaN 값이 반환된다.
```
원시 타입에서 객체로의 변환
- 문자열 => String()
- 숫자 => Number()
- 불리언 => Boolean()

※ null, undefined은 변환할 수 없다.

### 3.8.1 변환과 동치
자바스크립트는 값의 타입을 유연하게 변화시킬 수 있어 동치 연산자(“==”)도 유연하게 동작한다.

하지만, 서로 변환 가능하다고 해서 동치인 것은 아니다.
```javascript
null == undefined	//true
“0” == 0		//true
0 == false		//true
undefined == false	//false undefined는 if문에서 false처럼 사용되지만 평소에는 아니다.
```

### 3.8.2 명시적 변환
타입을 명시적으로 변환할 필요성이 느껴질 때가 있다.
명시적 변환 방법
1. Boolean(), Number(), String(), Object() 함수 사용(래퍼 함수)
(해당 방식으로 사용된다면 임시 객체가 아니라 제대로 된 객체를 만들어준다)
2. 연산자를 통한 암시적(implicit) 타입 변환
```javascript
x + “”	// String(x)와 같다.
+x	// Number(x)와 같다. 결과 x-0.
!!x 	// Boolean(x)과 같다. 예를 들어 x가 빈 문자열이라면 !x 면 true !!x false 값이 나와서 원 값이 나온다.
```

Number 클래스에 정의된 toString() 메서드는 기수(radix)를 정하는 인자를 받는다. default 값은 10이다. (2를 넣으면 2진수, 8을 넣으면 8진수 등)

Number 클래스에서는 소수점 이하 자릿수 제어를 위해 세 가지 메서드를 제공한다.
1. toFixed() : 자릿수 개수를 인자와 똑같이 맞춤.
2. toExponential() : 지수 표기 법을 사용하여 소수점 앞에 숫자 하나와 소수점 뒤에 인자로 지정한 만큼의 자릿수를 놓는 방식.
3. toPrecision() : 유효 자릿수가 숫자의 정수 부분을 표시할 정도로 크지 않는다면 지수 표기법을 사용.

>위의 세가지 메서드 모두 문자열 내에서 나머지 숫자들을 적절히 반올림하거나, 필요한 경우 0을 붙인다!

Number에서는 10진수 정수만 처리할 수 있고 그 뒤에 숫자 아닌 문자가 오는 것을 허용하지 않지만 허용해주는 parseInt()와 parseFloat()가 있다. 이는 Number 클래스 내의 메서드가 아닌 **전역함수**
위의 함수들은 빈 공백이나 숫자가 아닌 문자들을 전부 무시해서 처리한다. 만약 첫 번쨰 공백이 아닌 문자가 유요한 숫자 리터럴이 아니라면 NaN를 반환한다.

### 3.8.3 객체에서 원시 타입으로 변환
1. 객체 => 불리언
모든 객체(배열과 함수를 포함)은 true로 변환이 간단.
new Boolean(false) 또한 **원시 타입**이 아니라 객체이므로 true로 반환.

2. 객체 => 문자열, 숫자
- toString()
객체의 메서드를 호출함으로써 수행(객체를 문자열 or 숫자로 변환해주는 default 메서드가 있음) -> 다소 복잡하다

※현재 단원에서 설명하는 문자열, 숫자로의 변환 규칙은 네이티브 객체일 때만 가능.

함수를 문자열로 변경시키면 함수를 자바스크립트 소스 코드 형태의 문자열로 변환
RegExp객체를 문자열로 변경해도 RegExp 리터럴을 그대로 문자열로 만들어 반환한다.
Date 클래스에는 사람이 읽을 수 있는 문자열을 반환한다
```javascript
[1,2,3].toString()		// “1, 2, 3“
(function(x) { f(x); }).toString()	// “function(x) {\n f(x); \n}“
/\d+/g.toString()	// “/\\d+/g“
new Date(2010,0,1).toString()	// “Fri Jan 01 2010 00:00:00 GMT-0800 (PST)“
```

- valueOf()
기본적으로 원시 타입을 반환
래퍼 클래스에서는 해당 메서드를 이용하면 래핑된 원시 타입의 값을 반환
배열, 함수, 정규 표현식은 기본 메서드를 상속 메서드를 사용하면 객체 본인을 반환한다.
Date 클래스는 객체 내부적으로 날짜를 표현할 때 쓰는 값을 반환한다.

객체를 문자열로 바꾸는 동작 방식
1. 객체가 toString()메서드를 가지고 잇다면 메서드를 호출하여 원시 타입 값 또는 문자열로 변환하여 반환
2. toString()이 없다면 valueOf() 메서드를 찾아 호출한다. 반환값이 원시 타입이라면 자바스크립트는 문자열로 변환하여 반환
3. 위의 사항에 해당하지 않는다면 TypeError 발생

객체를 숫자로 바꾸는 동작 형식
문자열과 동의하지만 valueOf() 메서드를 우선적으로 찾는다.

빈 배열이 숫자 0으로 변환되는 이유?
valueOf() 메서드가 가장 먼저 작동되는데 해당 메서드는 객체 내부에서 사용되는 값을 반환시킨다. 배열 내에 아무런 값이 없다면 false로 처리 되기 때문에 이를 값으로 따지면 0에 해당되는 것 같다.
정답 : 배열은 기본적으로 원시 타입 값 대신 객체를 반환하는 valueOf() 메서드를 상속, 배열에서 숫자로의 변환은 toString() 메서드에 의존.
빈 배열 => 빈 문자열 => 0으로 변환
한 개의 숫자를 가진 배열 => 한 개의 숫자를 뜻하는 문자열 => 숫자

‘+’ 연산자의 **피 연산자 중 하나가 객체**라면 자바스크립트에서는 숫자로 변환하는 대신 원시 타입으로 변환한다. (‘==’ 동치 연산자도 유사 **객체를 원시 타입 값과 비교**할 경우 객체를 원시 타입으로 변환)

예외적으로 Date타입은 자바스크립트에서 유일하게 문자열, 숫자로의 변환 절차가 전부 구현되어있는 타입. 
default 객체에서 원시 타입으로 변환은 객체에서 숫자로의 변환 => valueOf() 사용
Date 객체에 한해서만 객체에서 문자열로 변환하며, 이때 toString() 사용

‘<’ 는 Date 또한 다른 연산자처럼 객체에서 원시 타입으로 변호나하여 수행

‘+, ==, !=’그리고 관계 연산자만이 이런 특별한 문자열-원시타입 변환과정을 갖는다.
다음 코드를 통해 ‘+, -, ==, >’ 연산자와 Data객체와의 상호작용을 보여준다.
```javascript
var now = new Date();	//Date 객체 생성
typeof (now + 1)	// “string” : +sms 날짜를 문자열로 변환시킨다.
typeof (now – 1)	// “number“ : -는 객체에서 숫자로 변환시킨다.
now == now.toString()	// true : 암시적 그리고 명확한 문자열 반환
now > (now –1)		// true : > Date에서 숫자로 변환
```
>요약 : 객체-원시 타입 값의 변환 과정에서는 toString()과 valueOf() 둘 다 이용해서 진행 단지, 각자의 객체 또는 연산자가 들어가게 된다면 우선순위가 존재

## 3.9 변수 선언
자바스크립트의 변수 선언 키워드 : var

var문에서 변수에 초기 값을 지정하지 않는 다면 undefined값을 가지고 있는다.

var 문은 for and for/in 루프 안에 올 수 있다.
```javascript
for(var i = 0; i < 10; i++) console.log(i);
for(var p in o) console.log(p);
```
따로 타입을 잡아주지 않아도 똑똑쓰~

### 3.9.1 반복된 선언과 생략된 선언
var로 하나 이상의 변수 선언 가능. 초기값이 부여되면 마치 대입문처럼 행동한다.

선언하지 않는 변수를 읽으려 하면 자바스크립트는 에러를 발생.

엄격 모드에서는 선언하지 않은 변수에 값을 넣으려 해도 에러가 발생
비-엄격 모드에서는 선언하지 않는 변수에 값을 배정하면 전역 객체의 속성으로 생성되어 전역 변수처럼 사용가능하지만 나쁜 습관

## 3.10 변수의 유효범위
변수의 유효범위 : 변수가 정의되어 있는 영역
전역 변수의 유요범위는 전역적 자바스크립트 코드 전체에 걸쳐 정의되어 있다.
but, 함수 안에 선언된 변수는 함수 안에서만 사용가능하다. 함수의 매개변수 역시 지역 변수에 해당한다.

같은 이름을 갖는 경우, 함수 내부에서 지역 변수는 전역 변수에 우선한다.

전역 유효범위에서는 var문을 사용하지 않고 전역 변수를 선언할 수 있지만, 지역 변수를 선언하기 위해서는 반드시 **var**를 사용해야 한다.
```javascript
scope = “global”;

function checkscope2() {
    scope = “local”;		// 해당 줄에서 전역 변수 자체를 바꿔버린다.
    myscope = “local”;	// 암묵적으로 전역 변수를 실행한다.
    return [scope, myscope];
}
checkscope2()		//[“local“, “local“]
scope			// “local“
myscope		// “local“
```
함수 내에서 전역 변수 선언이 가능하다.

### 3.10.1 함수 유효범위와 끌어올림(hoisting)
다른 언어에서 지역 변수는 해당 변수가 선언되지 않은 블록 밖에서는 사용하기가 어렵다. 이를 **블록 유효범위(block scope)**라 한다. 자바스크립트에서는 블록 유효범위 대신 함수 유효범위를 사용한다.

변수는 해당 변수가 정의된 함수 안에서 보일 뿐 아니라, 그 함수 안에 중첩된 함수 안에서도 보인다.
```javascript
function test(o) {
    var i = 0;			// i는 함수 전체에 걸쳐 사용가능
    if(typeof o == “object”) {
        var j = 0;			// j는 블록 뿐만 아니라 함수 전체에서 사용가능
        for(var k=0; k < 10; k++) {	// k는 반복문 외에도 함수 전체에서 사용가능
        console.log(k);
        }
    console.log(k);			// 10출력
    }
console.log(j)			// undefined 출력
}
```
위의 코드를 보면 함수의 정의는 어떤 위치에서 선언하든 함수 내 어디서든지 정의되어 사용할 수 있지만 초기화된 변수 값은 블록 내에서만 사용가능하다 위의 코드에서 j를 통해 확인 가능하다. j는 if문 안에서 0으로 초기화되었지만 그 밖에서는 초기화되지 않음을 뜻하는 undefined가 출력된다.

위의 특징을 끌어올림(hoisting)이라고 하는데, 이는 자바스크립트 코드의 함수 내에 있는 변수 모드를 처음에 선언한 것처럼 동작하기 때문이다.
```javascript
var scope = “global”;
function f() {
    console.log(scope);		// undefined 출력
    var scope = “local”;		// 초기화 부분
    console.loh(scope);		//“local“ 출력
}
```
해당 코드를 통해 함수 내의 변수 정의하는 위치가 상관없다는 것과 그 영향력을 알 수 있다.

블록 유효범위를 가진 프로그래밍 언어에서 일반적으로 변수를 선언하기 좋은 방법은 그 변수가 사용되는 가장 가까운 곳에 선언하는 것이지만 자바스크립트는 블록 유효범위가 없기 때문에 함수의 맨 꼭대기에 선언하면 된다.

### 3.10.2 프로퍼티로서의 변수
전역 자바스크립트 변수는 사실 전역 객체의 프로퍼티를 정의하는 것이다.(3.5절 Date, Number 등 정의 되어있는 객체)

var를 통한 변수 선언은 생성된 프로퍼티는 수정 가능하지 않고, delete 연산자로 소멸시킬 숭 없다는 뜻이 된다.

비-엄격 모드에서 선언 안한 변수에 값을 대입하면 전역 객체의 전역 변수가 선언되는데 이때에는 수정가능하고 삭제 가능한 전역 객체의 프로퍼티가 된다.

※ 자바스크립트에서는 this 키워드로 전역 객체를 참조할 수 있지만 지역 변수가 저장된 객체를 참조할 방법은 제공하지 않는다. (아직은 모르겠다 무슨 말인지)

### 3.10.3 유효범위 체인
- 전역 변수 : 코드 전체에 유효
- 지역 변수 : 선언된 함수 + 중첩된 함수 내에서 유효

변수를 사용해야 될 경우가 있을 때 참조하는 부분을 변수를 정의하는 객체의 체인이라고 한다. 체인은 객체를 보관하고 있고 리스트 형식으로 되어있다. 전역 변수 같은 경우는 체인이 단 하나의 전역 객체로 이루어져있고 중첩되지 않은 함수 같은 경우는 함수 매개변수와 지역변수를 정의하는 객체, 전역 객체 이렇게 두 개의 객체가 체인에 존재한다. 우선순위에 따라 순서대로 확인하는 방식

객체의 유효범위 체인이 만들어지는 과정
함수가 정의 될 때 함수의 유효범위 체인을 저장한다.
-> 함수가 호출될 때, 해당 함수의 지역 변수를 저장하기 위해서 새로운 객체를 하나 생성하고, 해당 객체를 기존에 저장된 유효범위 체인에 추가한다.
-> 중첩 함수의 경우 외부에서 함수를 호출할 때마다 중첩된 함수가 매번 선언되기 때문에 호출될 때마다 유효범위 체인이 조금씩 달라진다. 