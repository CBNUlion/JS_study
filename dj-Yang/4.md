# 4장 표현식과 연산자
표현식 : 자바스크립트 인터프리터가 값으로 평가하는(evaluate) 자바스크립트 구문이다.

배열의 접근 표현식은 열린 대괄호와 숫자로 평가되는 표현식, 닫힌 대괄호가 결합된 하나의 표현식이다.
이렇게 결합된 복합 표현식은 배열의 특정 위치에 저장된 값으로 평가되고, 함수 호출 표현식 도한 복합 표현식 중 하나이다.

복합 표현식을 만드는 가장 쉬운 방법 -> 연산자(operator) 이용

## 4.1 기본 표현식
다른 표현식을 포함하지 않은 독립적 표현식, 상수나 리터럴 값, 특정 키워드, 변수 참조를 말한다.

자바스크립트에서는 프로그램 안에 존재하는 각 식별자들을 일단 변수라고 가정하고 값을 살펴본다. 해당 하는 변수가 없다면 undefined 값으로 평가

## 4.2 객체와 배열의 초기화 표현식
새로 생성된 객체나 배열을 값으로 하는 표현식들은 기본 표현식이 아니다.
이들은 프로퍼티와 원소의 값을 지정하는 수많은 하위 표현식을 포함할 수 있기 때문이다.

배열 초기화 표현식
- 대괄호 안에 담긴 쉼표로 구분된 표현식 리스트
- 쉼표로 구분되는 각각의 원소들 또한 표현식(각각의 원소를 배열로 놓을 수 있어 중첩 배열도 가능함)
- 배열 초기화 표현식에 사용되는 원소 표현식은 매번 배열이 초기화될 때마다 평가(평가때마다 원소의 값이 달라질 수 있음)
- 배열 리터럴에서 쉼표 사이의 값을 생략함으로써 원소의 값을 정의하지 않을 수 있음
```javascript
var sparseArray = [1,,,,5];
```
객체 초기화 표현식
- 배열 초기화 표현식과 유사
- 대괄호가 아닌 중괄하고 사용
- 각 하위 표현식 앞에는 프로퍼티 이름과 콜론이 붙음
- 객체 리터럴 또한 중첩될 수 있음
- 객체 초기화에 사용한 표현식은 객체가 초기화 될 때마다 평가
- 객체 리터럴에서의 프로퍼티 이름으로는 식별자 대신 문자열을 사용할 수도 있음

## 4.3 함수 정의 표현식
함수를 정의하고, 함수 정의 표현식의 값은 새로 정의된 함수. ‘함수 리터럴’ 이라고 할 수 있다.

함수 정의 표현식은 함수 이름을 포함할 수 있다.

## 4.4 프로퍼티 접근 표현식
프로퍼티 접근 표현식은 객체의 프로퍼티나 배열의 원소 값으로 평가
자바스크립트에서 프로퍼티 접근 문법
1. 표현식.식별자
2. 표현식[표현식]

첫 번째 문법에서 표현식은 객체를 의미, 식별자는 객체에서 찾을 프로퍼티를 의미
두 번째 문법에서 두변째 표현식은 객체의 특정 프로퍼티 이름 또는 배열 내 원소의 인덱스

두 프로퍼티 모두 ‘,’과 ‘[’ 왼쪽 표현식이 먼저 평가된다. 평가된 값이 null이나 undefined이면 에러가 발생.
만약, 평가 값이 객체가 아니라면 객체로 변환한다.(래퍼)

객체 표현식 다음에 점과 식별자과 올 경우 식별자를 이름으로 갖는 프로퍼티 값을 찾음.
객체 표현식 다음에 두 번째 표현식이 담긴 대괄호가 올 경우 두 번째 표현식이 평가되고 이 값이 문자열로 변환.
두 가지 경우 객체에 해당 프로퍼티가 없다면 undefined 값을 접근 표현식이 갖는다.

## 4.5 호출 표현식
호출 표현식 : 자바스크립트에서 함수나 메서드를 호출하는 문법. 호출될 함수를 가르키는 함수 표현식으로 시작한다.
```javascript
f(0)		// f는 함수 표현식, 0: 호출 인자
Math.max(x,y,z) // Math.max 함수, x,y,z: 호출 인자
a.sort()		// a.sort는 함수, 호출인자 x
```

호출 표현식의 평가 순서
1. 함수 표현식이 가장 면저 평가
	- 함수 표현식의 값이 호출할 수 있는 객체가 아닐 경우 에러 발생
2. 호출 인자 표현식이 순서대로 인자 값으로 평가
3. 인자 값이 평가된 다음에는 함수 선언시 지정되었던 인자 이름에 인자값이 할당
4. 값을 반환시키기 위해 return문을 사용할 경우 그 값이 **호출 표현식의 값**
	- 함수가 값을 반환하지 않을 경우 함수 표현식의 값은 undefined

모든 호출 표현식은 한 쌍의 괄호와 괄호 앞에 오는 표현식으로 이뤄지는데, 표현식이 프로퍼티 접근 표현식이라면 메서드 호출이 되고 메서드가 호출되며 함수의 몸체가 실행되면 프로퍼티 접근 표현식이 가르키는 객체나 배열이 모두 this의 값이 된다.

>**메서드 호출이 아닌 호출 표현식**은 보통 전역 객체를 this 키워드의 값으로 사용한다. 하지만 ES5에서는 메서드 호출이 아닌 호출 표현식을 ‘엄격 모드’에서 사용할 경우, 전역 객체 대신 undefined가 this의 값이 된다.

## 4.6 객체 생성 표현식
새 객체를 생성, 생성자라고 부르는 함수를 호출해 객체에 속한 프로퍼티들을 초기화.

호출표현식과 유사하지만 앞에 **new**키워드가 붙는다.

객체 초기자 {}에 의해 생성되는 생성자는 this를 통해 값을 전달한다.

## 4.7 연산자 개요
대부분의 연산자가 +, -와 같이 기호로 표현되지만, 일부는 delete와 instanceof와 같이 키워드로 표현

### 4.7.1 피연산자 개수
연산자에 필요한 피연산자에 개수에 따라 연산자들을 분류 가능

사칙 연산처럼 자바스크립트의 대부분의 연산자는 피연사자를 2개로 갖는 2항 연산자에 해당
++, --, -x(부호를 바꿔줌)과 같이 단항 연산자도 존재
삼항 연산자도 존재 : <?:>

### 4.7.2 피연산와 반환 타입
일부 연산자를 제외하곤 대부분의 연산자가 반환타입이 지정되어 있다.

자바스크립트는 필요할 때마다 피연산자 타입을 변환
```javascript
‘3’ * ‘5’		//숫자 15
```

### 4.7.3 좌변 값
>할당 표현식의 좌변에 나타날 수 있는 표현식, 변수, 객체 프로퍼티, 배열 원소 등

### 4.7.4 연산자 부수 효과
자바스크립트에서 일부 표현식은 **부수 효과**를 가진다. 대표적으로 **할당 연산자**가 있다.

변수나 객체의 프로퍼티에 값을 할당하면 그 변수나 프로퍼티를 사용하는 모든 표현식의 값이 바뀌는 것

delete 연산자 또한 undefined 값을 할당하는 것과 유사하다.

### 4.7.5 연산자 우선순위
연산자끼리도 우선순위가 존재한다.
할당된 우선순위를 변경하고 싶다면 명시적으로 괄호를 사용.

프로퍼티 접근이나 호출 표현식은 연산자들보다 항상 우선순위가 높다.
```javascript
typeof my.functions[x](y)
```
typeof 연산자는 우선순위가 높지만 프로퍼티 접근과 함수 호출이 끝난 후에야 실행

>곱셈과 나눗셈은 덧셈과 뺄셈보다 먼저 수행, 할당은 우선순위가 아주 낮기 때문에 대부분의 경우 마지막에 수행

### 4.7.6 연산자 결합 방향
연산자 결합 방향이 지정되는 것은 동일 우선순위 연산자들간의 수행 순서를 의미

### 4.7.7 평가 순서
연산자 우선순위와 결합 방향은 복잡한 표현식에서 어떤 연산이 우선적으로 수행되는 지를 결정한다. 하지만, 어떤 부 표현식이 먼저 평가되는지는 정해지지 않음
```javascript
w=x+y*z;	//부 표현식 w가 머저 평가되고, x, y, z가 차례대로 평가된다
```
평가 순서는 표현식 가운데 다른 표현식의 값에 영향을 끼치는 표현식이 있을 때 유의해야한다.

## 4.8 산술 표현식
피연산자들에 산술 연산이나 기타 수치 조작을 하는 연산자에 대해 다룬다.

### 4.8.1 덧셈 연산자:＋
＋연산자가 이항 연산자로 사용될 때는 피연산자의 숫자 값을 더하거나 피연산자의 문자열을 이어 붙인다.

두 피연산자의 값이 모두 숫자거나 문자열인 경우에는 + 연산자가 하는 일이 명확, 그 외의 경우는 타입 변환이 이루어져야하고, 연산은 타입 변환 후에 이루어진다.

+ 연산자는 타입 변환 시에 문자열 이어붙이기를 먼저 수행, 피연산자 중 하나가 문자열이거나 문자열로 바꿀 수 있는 객체라면 다른 피연산자를 문자열로 변환하여 붙인다. 숫자 덧셈은 두 피연산자 값이 모두 문자열이 아니거나 문자열로 변환될 수 없을 때만 수행.
+ 두 개의 피연산자 타입이 다를 때 연산자 동작 방식
1. 하나의 피연산자 값이 객체일 경우, 원시 타입 변환(3.8.3절)을 통해 원시 타입으로 변경 
2. 피연산자가 객체에서 원시 타입으로 변환된 후 어떤 피연산자라도 문자열이면, 다른 피연산자를 문자열로 변경 후 이어 붙인다.
3. 일반적인 덧셈 함수 시행

+ 연산자는 여러 문자열과 여러 숫자를 함께 사용할 때는 연산자 결합 법칙이 적용 되지 않는다.
```javascript
1 + 2 + “ test”;		// ’3 test’
1 + (2 + “ test”);	// ’12 test’
```

### 4.8.2 단항 산술 연산자
단항 연산자는 하나의 피연산자 값을 수정해서 새 값으로 만든다.

1. 단항 덧셈
피연산자를 숫자(또는 NaN)로 바꾼 후 반환, 피연산자가 숫자인 경우에는 아무 일도 하지 않는다.

2. 단항 뺄셈
피연산자를 숫자로 변환하려고 시도, 성공할 경우 결과 값의 부호를 바꾼다.

3. 증가(++)
피연산자에 대해 증가 연산 진행, 피 연산자는 반드시 좌변 값 이어야한다.

이러한 좌변 값이 숫자가 아닐 경우 ++ 연산자는 이를 숫자 타입으로 변환하고 1을 더한 후 원래 좌변 값에 대입한다.
```javascript
x = “1”;
x++;	// 2
x+1;	// ’11’
```

4. 감소(--)
증가 연산자와 같지만 값을 감소시킨다.

### 4.8.3 비트 단위 연산자
2진수를 저수준에서 조작하는데 사용.

비트 단위 연산자 중 네 종류(&, |, ^, ~)는 피연산자의 개별 비트에 대해 불리언 대수를 수행, 이때 피연산자의 개별 비트를 불리언 값으로 취급한다. 다른 세 종류의 비트 단위 연산자(<<. >>, >>>)는 왼쪽이나 오른쪽으로 비트를 이동할 때 사용.

비트 단위 연산자의 피연산자는 정수, 여기서 64비트 부동 소수점 표현법이 아니라 32비트 정수 표현법을 따른다. 비트 단위 연산자는 피연산자의 값을 가능하면 숫자로 바꾸고 32번째 이후 비트를 잘라내어 강제로 32비트로 만들고, ㅇ동 연산자는 우측 피연산자의 값이 0과 31 사이의 값이어야한다. 피연산자를 32비트 정수로 변환한 후 여섯 번째 이상의 비트를 버림으로써 범위를 조정한다.

>비트단위 연산자에서는 NaN, 양의 무한대, 음의 무한대가 모두 0의 값으로 바뀐다.

- 왼쪽으로 이동(<<)
첫 번째 피연산자의 모든 비트를 두 번째 피연산자에서 지정한 자릿수만큼 왼쪽으로 이동.
두 번째 피연산자는 0과 31 사이의 정수, 새로 만들어지는 비트의 값은 0이 사용되며 기존의 32비트의 값은 삭제된다.

- 부호를 보존하며 오른쪽으로 이동(>>)
왼쪽으로 이동과 동일하지만 새로 채워질 비트는 최초 피연산자의 부호피트가 되고, 이는 곧 결과 값의 부호를 의미, 첫 번째 피연산자가 양수면, 결과 값의 최상우ㅢ 비트가 0이 되고, 음수면 최상위 비트 1이 된다.

- 0으로 채우며 오른쪽으로 이동(>>>)
*부호를 보존하며 오른쪽으로 이동*과 전부 동일하지만 새로운 비트가 무조건 0의 값을 가진다.

## 4.9 관계형 표현식
자바스크립트에서 관계형 연산자를 다룬다. 결과 값은 불리언 값(true, false)를 반환하고 주로 프로그램 실행의 흐름을 제어하기 위한 if문, while문, for 루프문에서 주로 사용

### 4.9.1 동치와 부등치 연산자
==와 === 연산자 모두 주어진 두 값이 같은지를 확인하지만 같음을 뜻하는 바가 다르다.

1. ===(일치)
엄격한 동치로 알려져있으며 기준을 매우 엄격하게 정의, 두 피연산자가 일치하는 지 확인.

2. ==(동치)
두 피연산자가 동등한 지 확인할 때 필요한 경우 타입 변환을 허용, 일치 연산자만큼 엄격하지는 않음.

3. !=(부등치)
두 값이 서로 동치일 경우 false를 반환, 그렇지 않을 경우 true를 반환,
!연산자의 뜻을 생각하면 ‘같은 값으로 볼 수 없다’라고 나타냄.

4. !==(불일치)
두 값이 서로 일치할 경우 false, 아닐 경우 true 반환, ! 연산자의 뜻을 생각하면 ‘일치하지 않는다’라고 나타냄

이전에 말했듯이 자바스크립트는 값 비교가 아닌, 참조 비교를 수행(객체는 자기 자신과 같지만 다른 객체와는 같지 않다. 배열 역시 마찬가지.

일치 연산자 (===) 두 값이 일치하는 지 여부를 판단할 때의 규칙, 타입 변환은 하지 않음.
- 두 값의 타입이 서로 다르면 두 값은 불일치
- 두 값이 모두 null이거나 모두 undefined면, 두 값은 일치
- 두 값이 모두 불리언 값 true이거나 모두 false일 경우 일치
- 적어도 하나의 값이 NaN이면 불일치(임의의 값 x가 NaN인지 검사 방법 : x !== x)
- 두 값이 모두 숫자고 같은 값이면 일치(하나의 값이 0이고 나머지 하나의 값이 –0이라도 일치)
- 두 값이 모두 문자열이고, 같은 위치에 정확히 같은 16비트 값을 가지고 있다면 일치, 길이나 내용이 다를 경우 불일치(문자열 비교는 String.localecomper() 이용)
- 두 값이 모두 같은 객체나 배열 또는 함수를 참조하면 두 값은 일치

동치 연산자 (==) 두 값의 동치 여부 판단 기준, 일치에 비해 상대적으로 엄격하지 않음, 필요에 따라 타입을 변환하기도 함
- 두 값의 타입이 같은 경우, 두 값이 일치하는 지 확인 일치하면 동치
- 두 값의 타입이 다른 경우
	1. 두 값 중 하나가 null이고 다른 하나가 undefined라면 동치
	2. 한 값이 숫자고 다른 하나가 문자열이면, 문자열을 숫자로 변환한 후 이를 사용해 다시 비교
 	3. 두 값 중 하나가 true면 이를 1로 변환한 후 다시 비교, false일 경우 0으로 변환
	4. 한 값이 객체고, 다른 하나는 숫자 또는 문자열이면, 객체를 원시 타입의 값으로 변환 후 다시 비교(객체를 원시 값으로 변환할 경우 toString()메서드나 valueOf() 메서드가 사용된다)
	5. 앞에서 열거하지 않은 기타 값들의 조합은 동치가 아니다.

### 4.9.2 비교 연산자
두 피연산자 값의 상대적인 순서를 판단(<, >, <=, >=)

비교 연산자는 피연산자 타입에 제한이 없다. 하지만 오직 숫자와 문자열만 비교할 수 있기 때문에 숫자가 문자열이 아닌 피연산자는 먼저 변환한다.
1. 피연산자 중 어느 하나가 객체로 평가되면, 해당 객체가 원시 값으로 변환(toString(), valueOf())
2. 원시 타입으로 변환된 후에 피 연산자가 모두 문자열이라면 ‘알파벳 순서’대로 두 문자열을 비교(유니코드 값의 순서)
3. 피연산자 중 하나가 문자열이 아니면 피연산자 모두 숫자로 변환 후 값을 비교, 둘 중의 하나의 피연산자가 NaN이거나 NaN으로 변환된다면 비교 연산자는 언제나 false를 반환

자바스크립트 문자열은 16비트 정수 값들의 나열이고, 문자열 비교는 단순히 각 문자에 해당하는 숫자를 비교하는 것 => 비교를 도와주는 String.localeCompare() 메서드를 자바스크립트에서 제공해주고, 대소문자와 상관없이 비교하려면 전부 대문자로 만들어주거나 소문자로 만들어줘야 한다.

+ 연산자는 문자열을 선호(숫자 + 문자열 = 문자열), 비교 연산자는 숫자를 선호.

### 4.9.3 in 연산자
in 연산자는 좌변의 피연산자로 문자열(또는 문자열로 변환 가능한 것)을 받는다. 우변의 피 연산자로는 객체나 배열을 받는다.
```javascript
var point = { x:1, y:1};
“x” in point		// true
“z” in point		// false
“toString” in point	// true :상속된 프로퍼티

var data = [7, 8, 9];
“0” in data		// true 배열의 0번째 원소가 있음
“1” in data		// true 배열의 1번째 원소가 있음
7 in data		// false
“7” in data		// false
//위의 코드를 보면 모든 값이 문자열로 변경되기 때문에 원소 값의 존재 여부만 판단할 수 있음을 나타낸다.

### 4.9.4 instanceof 연산자
좌변의 피연산자로는 객체, 우변의 피연산자로 객체 클래스의 이름을 식별자로 받는다.
좌변에 있는 객첵 우변 클래스의 인스턴스일 경우 연산 결과를 true로 평가.

자바스크립트 특성상 객체의 클래스는 객체를 초기화하는 생서자 함수로부터 정의 되므로 우변 피 연산자는 함수가 된다.

>모든 객체는 Object의 인스턴스라는 점도 기억!

instanceof로 판단할 때는 해당 객체의 **상위 클래스**도 고려한다.

o instanceof f 표현식의 평가 방법
- f.prototype을 평가한 후, 그 값이 o의 프로토타입 체인에 나타나는 지 검색. 발견되면 true

## 4.10 논리표현식
불리언 대수를 수행한다. 또한, 종종 비교 연산자와 함게 사용되어 둘 이상의 변수가 관계되는 복잡한 표현식을 표현

### 4.10.1 논리 AND(&&)
1. 두 연산자의 값에 대한 불리언을 수행
2. 두 관계 표현식의 접속사 역할
	- 관계식은 항상 true나 false로 평가
3. 연산자는 좌변에 있는 첫 번째 피연산자를 먼저 평가, 만약 값이 ‘falsy’에 해당한다면 우변은 평가하지 않고 좌변의 ‘falsy’를 반환. 첫 번째 피연산자가 ‘truthy’에 해당하면 우변의 값을 평가하여 그 값을 반환한다.
```javascript
var o = { x : 1 };
var p = null;
o && o.x	// 1: o가 객체이기 때문에 truthy, 따라서 o.x를 반환
p && p.x	// null : p가 null(falsy)값이기 때문에 우변을 평가하지 않고 반환
```
위와 같은 동작 방식을 **단축 평가**라고 한다.

아래는 단축 평가를 이용하는 코드
```javascript
if (a == b) stop();
(a == b) stop();
```
위의 두 개의 코드는 동작 방식이 같다.

### 4.10.2 논리 OR(||)
|| 연산자는 좌변에 있는 첫 번째 피연산자 표현식을 평가하는 것으로 시작한다.
좌변의 값이 true로 평가되는 값이면, 전체 표현식이 좌변의 값이 된다. 만약 false로 평가되는 값이면 두 번재 피연산자를 평가하고, 결과와 무관하게 두 번째 피연산자 값이 표현식의 값으로 반환

### 4.10.3 논리 NOT(!)
! 연산자는 단항 연산자, 단일 피연산자 앞에 놓이고 목적은 불리언 값의 반전으로 사용.
연산자는 피연산자 값을 반전하기 전에 불리언 값으로 변환. 따라서 항상 ! 연산자는 true나 false를 반환

>>!!x를 이용하면 x에 대한 불리언 값을 알 수 있다.

## 4.11 할당 표현식
= 연산자를 사용해 변수나 프로퍼티에 값을 할당
좌변 피연산자로는 좌변 값(변수, 객체 프로퍼티, 배열의 원소)가 온다. 우변 피연산자로는 타입과 상관없고 할당 표현식의 값이 된다.

부수 효과로 오른쪽 값을 왼쪽의 좌변값에 할당하므로, 앞으로 그 좌변값을 사용하면 할당된 값을 참조하게 된다.

### 4.11.1 연산을 동반하는 할당
표현식
>a op= b;
위의 표현식은 a = a op b의 표현식과 같다. 하지만 위의 방식대로 하면 a가 한번 평가하되지만 아래 방법으로 하면 a가 두 번 평가된다.

위와 같은 방식에서 같지 않을 경우는 함수 호출이나 증가 연산자와 같은 부수 효과를 가질 시
```javascript
data[i++] *= 2;
data[i++] *= data[i++] * 2;
```
위의 두 식은 같지 않다.

## 4.12 평가 표현식
인터프리터 언어들과 마찬가지로 문자열을 자바스크립트 코드로 해석하고 이를 평가한 결과를 값으로 출력하는 기능이 있다 자바스크립트에서는 전역함수 **eval()**이 있다.

```javascript
eval(“3+2”)	// => 5
```

### 4.12.1 eval()
eval() 함수는 단 하나의 전달인자를 갖는다. 문자열이 아닌 값을 전달하면, 단순히 넘긴 값을 반환.
전달인자로 문자열을 전달하면 자바스크립트 코드로 해석
- 불가능할 경우 : SyntaxError
- 가능할 경우 : 코드를 평가한 후 코드에 포함딘 마지막 표현식 또는 구문의 값을 반환, 값이 없을 경우 undefined 값을 반환.
- 평가하는 도중에 예외가 발생 : eval()을 호출한 부분에서 전파

eval() 함수의 핵심은 호출되는 시점의 코드의 변수 환경을 사용한다는 점이다. 지역 코드와 똑같은 방식으로 변수의 값을 찾고, 새로운 변수나 함수를 정의.
- 함수 안에서 지역변수 x를 선언하고 eval(‘x’)를 호출하면 지역 변수 x의 값 반환
- eval(‘x=1’)을 호출하면 지역 변수 값을 변경
- eval(‘var y = 3;’)을 호출하면 새 지역변수 y를 선언

eval()을 최상위 레벨에서 호출하면, 당연히 전역변수나 전역함수를 대상으로 하게 된다.
eval()에 코드 문자열을 넘길 때는 반드시 독자적으로 의미를 갖는 코드를 인자로 넘겨야한다.

### 4.12.2 전역 eval()
eval()을 이용해 지역변수의 값을 변경 가능, 이것은 자바스크립트 최적화에 문제가 된다. ES3 에서는 eval()을 다른 이름으로 만드는 것을 에러를 발생시켜 만들었지만, 대부분의 구현체는 그렇지 않다. 다른 구현체에서는 최상위 레벨 전역 코드인 것처럼 평가된다.

ES5에서는 eval()의 기능을 표준화 시켰다. (direct eval이라 말한다)
eval()을 직접 호출 할 때는 문맥의 변수 환경을 그대로 사용, 그 외의 경우 즉 간접 eval() 호출 시에는 eval()의 변수 환경으로 전역 객체를 사용, 지역 변수나 지역 함수를 읽거나 쓰고 정의가 불가능하다
```javascript
var geval = eval;
var x = “global”, y = “global”;
function f() {
	var x = “local”;
	eval(“x += ‘changed’;”);
	return x;
}
function g() {
	var y = “local”;
	geval(“y += ‘changed’;”);
	return y;
}
console.log(f(), x);		//‘localchanged global’
console.log(g(), y);		//’local globalchanged’
```
이처럼 eval은 코드 문자열을 독립적인 최상위 스크립트인 것처럼 실행할 수 있기 때문에 굉장히 유용한 기능이다.

### 4.12.3 엄격 모드의 eval()
ES5 엄격모드에서는 eval을 식별자로 사용하는 것조차 제한하고 있다.

## 4.13 기타 연산자들
### 4.13.1 조건부 연산자 (?:)
보통 3항 연산자

### 4.13.2 typeof 연산자
단일 피연산자 앞에 위치하는 단항 연산자로, 어떤 타입이든 피연산자로 올 수 있다.

### 4.13.3 delete 연산자
단항 연산자로 피 연산자로 지정된 객체 프로퍼티, 배열 원소 또는 변수의 삭제를 시도. 보통 연산자가 가진 부수효과(프로퍼티 삭제) 때문에 사용하는 것(연산자 반환 값 x)
```javascript
var o = { x:1, y:2};
delete o.x;		//객체 프로퍼티 중 하나를 삭제한다. true 반환
```
삭제된 프로퍼티나 배열의 원소는 단순히 undefined값이 된 것이 아니라 더 이상 존재하지 않는다. 그러나, 존재하지 않은 값에 접근하려고 하면 undefined가 반환되므로 존재 여부는 in 연산자를 사용한다.

배열의 원소가 삭제 되면 배열에 빈 자리가 생기고, 배열의 길이 자체는 변하지 않는다.
```javascript
var a = [1,2,3];
delete a[2];		// 배열 원소를 지우고, true반환
a.length;		// 3
```

delete 연산자의 피연산자는 좌변 값이다. 좌변 값이 아닐 경우 단순히 true 값만 반환한다. 좌변 값일 경우 성공적으로 삭제를 했을 때에 true를 반환한다.

ES5 엄격 모드일 때는 delete 연산자를 사용할 때 피연산자가 부적합한 식별자일 경우 SyntaxError를 발생시킨다. 또한 엄격 모드에서 설정할 수 없는 프로퍼티를 삭제하려고 하면 TypeError를 발생시킨다. 엄격 모드가 아니라면 false를 반환한다.

### 4.13.4 void 연산자
이 연산자는 피연산자를 무시하고 undefined를 반환하는 것에 목적이 있다.

이 연산자의 가장 일반적인 사용처는 javascript:URL 이다.
URL은 어떤 자바스크립트 표현식의 부수효과를 평가할 대, 평가된 값을 브라우저에 표시하지 않으면서 표현식을 평가할 수 있게 해준다.
```html
<a href=“javascript:void wiondw.open();”>Open New Window</a>
```
위의 코드 대신 보통 onclick 이벤트 핸들러를 사용한다.

### 4.13.5 쉼표(,) 연산자
이 연산자는 왼쪽의 전달인자를 평가하고 오른쪽의 전달인자를 평가한 후, 오른쪽 전달인자의 값을 반환한다.

